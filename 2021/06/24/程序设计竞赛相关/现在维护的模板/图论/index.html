<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"manual"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="这里记录了图论方面平时个人常用的代码模板。">
<meta property="og:type" content="article">
<meta property="og:title" content="图论代码模板">
<meta property="og:url" content="http://example.com/2021/06/24/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E7%9B%B8%E5%85%B3/%E7%8E%B0%E5%9C%A8%E7%BB%B4%E6%8A%A4%E7%9A%84%E6%A8%A1%E6%9D%BF/%E5%9B%BE%E8%AE%BA/index.html">
<meta property="og:site_name" content="零岛">
<meta property="og:description" content="这里记录了图论方面平时个人常用的代码模板。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1596795/202009/1596795-20200927163453949-799155444.png">
<meta property="og:image" content="https://images.cnblogs.com/cnblogs_com/kikokiko/1638452/o_200601055952%E6%9C%80%E5%A4%A7%E5%AF%86%E5%BA%A6%E5%AD%90%E5%9B%BE1.png">
<meta property="og:image" content="https://images.cnblogs.com/cnblogs_com/kikokiko/1638452/o_200601065356%E6%9C%80%E5%A4%A7%E5%AF%86%E5%BA%A6%E5%AD%90%E5%9B%BE2%20(2).png">
<meta property="article:published_time" content="2021-06-24T07:43:37.000Z">
<meta property="article:modified_time" content="2023-01-27T13:21:17.125Z">
<meta property="article:author" content="Overstars">
<meta property="article:tag" content="算法模板">
<meta property="article:tag" content="图论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2020.cnblogs.com/blog/1596795/202009/1596795-20200927163453949-799155444.png">


<link rel="canonical" href="http://example.com/2021/06/24/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E7%9B%B8%E5%85%B3/%E7%8E%B0%E5%9C%A8%E7%BB%B4%E6%8A%A4%E7%9A%84%E6%A8%A1%E6%9D%BF/%E5%9B%BE%E8%AE%BA/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2021/06/24/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E7%9B%B8%E5%85%B3/%E7%8E%B0%E5%9C%A8%E7%BB%B4%E6%8A%A4%E7%9A%84%E6%A8%A1%E6%9D%BF/%E5%9B%BE%E8%AE%BA/","path":"2021/06/24/程序设计竞赛相关/现在维护的模板/图论/","title":"图论代码模板"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>图论代码模板 | 零岛</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">零岛</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">回朕车以复路兮，及行迷之未远</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">图论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">常见概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.1.</span> <span class="nav-text">网络流常用概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%A6%E5%9B%BE%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.2.</span> <span class="nav-text">弦图常用概念</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%BB%93%E8%AE%BA"><span class="nav-number">1.2.</span> <span class="nav-text">常见结论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%A6%E5%9B%BE"><span class="nav-number">1.3.</span> <span class="nav-text">弦图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%8A%BF%E7%AE%97%E6%B3%95%E6%B1%82%E6%B6%88%E9%99%A4%E5%BA%8F%E5%88%97%E5%B9%B6%E5%88%A4%E5%AE%9A%E5%BC%A6%E5%9B%BE"><span class="nav-number">1.3.1.</span> <span class="nav-text">最大势算法求消除序列并判定弦图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E5%85%83%E7%8E%AF"><span class="nav-number">1.4.</span> <span class="nav-text">三元环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.4.1.</span> <span class="nav-text">步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">1.5.</span> <span class="nav-text">最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dijkstra%E5%A0%86%E4%BC%98%E5%8C%96"><span class="nav-number">1.5.1.</span> <span class="nav-text">Dijkstra堆优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SPFA"><span class="nav-number">1.5.2.</span> <span class="nav-text">SPFA</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BFS%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">BFS实现（求最短路）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DFS%E4%BC%98%E5%8C%96%EF%BC%88%E8%B4%9F%E7%8E%AF%E6%A3%80%E6%B5%8B%EF%BC%89"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">DFS优化（负环检测）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE"><span class="nav-number">1.5.3.</span> <span class="nav-text">线段树优化建图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Floyd"><span class="nav-number">1.5.4.</span> <span class="nav-text">Floyd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Floyd%E6%B1%82%E6%9C%80%E5%B0%8F%E7%8E%AF"><span class="nav-number">1.5.5.</span> <span class="nav-text">Floyd求最小环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%9B%A2"><span class="nav-number">1.6.</span> <span class="nav-text">最大团</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%9B%A2%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.6.1.</span> <span class="nav-text">最大团大小</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F"><span class="nav-number">1.7.</span> <span class="nav-text">差分约束</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.7.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95"><span class="nav-number">1.7.2.</span> <span class="nav-text">解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98"><span class="nav-number">1.7.3.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-MST"><span class="nav-number">1.8.</span> <span class="nav-text">最小生成树(MST)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="nav-number">1.8.1.</span> <span class="nav-text">Prim算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruskal"><span class="nav-number">1.8.2.</span> <span class="nav-text">Kruskal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Boruvka"><span class="nav-number">1.8.3.</span> <span class="nav-text">Boruvka</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E4%BE%8B%E9%A2%98"><span class="nav-number">1.8.4.</span> <span class="nav-text">典型例题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CF888G-Xor-MST-%E5%BC%82%E6%88%96%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">1.8.5.</span> <span class="nav-text">CF888G Xor-MST 异或生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E6%84%8F"><span class="nav-number">1.8.5.1.</span> <span class="nav-text">题意</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">1.8.5.2.</span> <span class="nav-text">思路</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">1.9.</span> <span class="nav-text">次小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%B4%9B%E8%B0%B7P4180"><span class="nav-number">1.9.1.</span> <span class="nav-text">严格次小生成树(洛谷P4180)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88MDST%EF%BC%8C%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%EF%BC%89"><span class="nav-number">1.10.</span> <span class="nav-text">有向图最小生成树（MDST，最小树形图）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95%EF%BC%88Edmonds-%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.10.1.</span> <span class="nav-text">朱刘算法（Edmonds 算法）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B-1"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">模板</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kruskal%E9%87%8D%E6%9E%84%E6%A0%91"><span class="nav-number">1.11.</span> <span class="nav-text">kruskal重构树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="nav-number">1.11.1.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86"><span class="nav-number">1.12.</span> <span class="nav-text">矩阵树定理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="nav-number">1.12.1.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95"><span class="nav-number">1.12.2.</span> <span class="nav-text">扩展</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%A0%91"><span class="nav-number">1.13.</span> <span class="nav-text">虚树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-1"><span class="nav-number">1.13.1.</span> <span class="nav-text">步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.13.2.</span> <span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="nav-number">1.13.3.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">1.14.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%9B%BE%E6%90%9C%E7%B4%A2"><span class="nav-number">1.15.</span> <span class="nav-text">补图搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%9B%BE%E8%BF%9E%E9%80%9A%E5%9D%97-0-1-MST"><span class="nav-number">1.15.1.</span> <span class="nav-text">补图连通块 0-1 MST </span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E8%B7%AF"><span class="nav-number">1.16.</span> <span class="nav-text">欧拉路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E5%AE%9A"><span class="nav-number">1.16.1.</span> <span class="nav-text">判定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hierholzer%E7%AE%97%E6%B3%95"><span class="nav-number">1.16.2.</span> <span class="nav-text">Hierholzer算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E7%AC%94%E7%94%BB%E9%97%AE%E9%A2%98"><span class="nav-number">1.16.3.</span> <span class="nav-text">两笔画问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%89%E5%AF%86%E5%B0%94%E9%A1%BF%E5%9B%9E%E8%B7%AF"><span class="nav-number">1.17.</span> <span class="nav-text">汉密尔顿回路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E7%AE%80%E5%8D%95%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E7%8E%AF%E6%95%B0"><span class="nav-number">1.17.1.</span> <span class="nav-text">求简单无向图的环数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">1.18.</span> <span class="nav-text">强连通分量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Tarjan"><span class="nav-number">1.18.1.</span> <span class="nav-text">Tarjan</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Tarjan%E7%BC%A9%E7%82%B9-DAG-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8Fdp"><span class="nav-number">1.18.1.1.</span> <span class="nav-text">Tarjan缩点+DAG 拓扑排序dp</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-biconnected-component"><span class="nav-number">1.18.1.2.</span> <span class="nav-text">双连通分量(biconnected component)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%BC%A9%E7%82%B9"><span class="nav-number">1.18.1.2.1.</span> <span class="nav-text">点双连通分量缩点</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Tarjan%E6%97%A0%E5%90%91%E5%9B%BE%E6%B1%82%E5%89%B2%E7%82%B9"><span class="nav-number">1.18.1.3.</span> <span class="nav-text">Tarjan无向图求割点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E6%B1%82%E6%A1%A5"><span class="nav-number">1.18.1.4.</span> <span class="nav-text">无向图求桥</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-SAT%E9%97%AE%E9%A2%98"><span class="nav-number">1.18.2.</span> <span class="nav-text">2-SAT问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B-2"><span class="nav-number">1.18.2.1.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E5%9B%BE%E6%96%B9%E5%BC%8F"><span class="nav-number">1.18.2.2.</span> <span class="nav-text">建图方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%86%E6%96%B9%E6%A0%91"><span class="nav-number">1.19.</span> <span class="nav-text">圆方树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-LCA"><span class="nav-number">1.20.</span> <span class="nav-text">最近公共祖先(LCA)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%8D%E5%A2%9E"><span class="nav-number">1.20.1.</span> <span class="nav-text">倍增</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">1.20.1.1.</span> <span class="nav-text">应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86"><span class="nav-number">1.21.</span> <span class="nav-text">树上差分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8"><span class="nav-number">1.21.1.</span> <span class="nav-text">性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%82%B9%E7%9A%84%E5%B7%AE%E5%88%86"><span class="nav-number">1.21.2.</span> <span class="nav-text">点的差分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C"><span class="nav-number">1.21.2.1.</span> <span class="nav-text">操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9"><span class="nav-number">1.21.2.2.</span> <span class="nav-text">修改</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%B9%E7%9A%84%E5%B7%AE%E5%88%86"><span class="nav-number">1.21.3.</span> <span class="nav-text">边的差分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C-1"><span class="nav-number">1.21.3.1.</span> <span class="nav-text">操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-1"><span class="nav-number">1.21.3.2.</span> <span class="nav-text">修改</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.21.4.</span> <span class="nav-text">查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="nav-number">1.22.</span> <span class="nav-text">树链剖分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.22.1.</span> <span class="nav-text">通用模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#P3384-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="nav-number">1.22.2.</span> <span class="nav-text">P3384 树链剖分 </span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%82%B9%E5%88%86%E6%B2%BB"><span class="nav-number">1.23.</span> <span class="nav-text">点分治</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83"><span class="nav-number">1.23.1.</span> <span class="nav-text">树的重心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B-3"><span class="nav-number">1.23.2.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="nav-number">1.23.3.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6%EF%BC%88DSU-on-tree%EF%BC%89"><span class="nav-number">1.24.</span> <span class="nav-text">树上启发式合并（DSU on tree）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B-4"><span class="nav-number">1.24.1.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-3"><span class="nav-number">1.24.2.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-number">1.25.</span> <span class="nav-text">二分图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">1.25.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E4%BA%8C%E5%88%86%E5%9B%BE%E7%BB%93%E8%AE%BA"><span class="nav-number">1.25.2.</span> <span class="nav-text">常见二分图结论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E4%BB%BB%E6%84%8F%E5%9B%BE%E7%9A%84%E7%BB%93%E8%AE%BA"><span class="nav-number">1.25.3.</span> <span class="nav-text">适用任意图的结论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%EF%BC%88%E9%BB%91%E7%99%BD%E6%9F%93%E8%89%B2%E6%B3%95%EF%BC%89"><span class="nav-number">1.25.4.</span> <span class="nav-text">二分图判定（黑白染色法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="nav-number">1.25.5.</span> <span class="nav-text">匈牙利算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">1.25.5.1.</span> <span class="nav-text">邻接表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KM%E7%AE%97%E6%B3%95"><span class="nav-number">1.25.6.</span> <span class="nav-text">KM算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BFS%EF%BC%8C%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A8%B3%E7%9A%84%E4%B8%80%E6%89%B9"><span class="nav-number">1.25.6.1.</span> <span class="nav-text">BFS，复杂度稳的一批</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A6%E5%8F%B3%E6%95%B0%E7%9B%AE%E4%B8%8D%E7%AD%89%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.25.6.2.</span> <span class="nav-text">左右数目不等的模板</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CSL%E7%9A%84%E5%86%99%E6%B3%95"><span class="nav-number">1.25.6.3.</span> <span class="nav-text">CSL的写法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="nav-number">1.26.</span> <span class="nav-text">网络流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86"><span class="nav-number">1.26.1.</span> <span class="nav-text">最大独立集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE"><span class="nav-number">1.26.2.</span> <span class="nav-text">最大权闭合子图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-1"><span class="nav-number">1.26.2.1.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AF%86%E5%BA%A6%E5%AD%90%E5%9B%BE"><span class="nav-number">1.26.3.</span> <span class="nav-text">最大密度子图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%951-%E4%BA%8C%E5%88%86%EF%BC%8C%E5%A4%8D%E6%9D%82%E5%BA%A6-logn-maxflow-n-m-n-m"><span class="nav-number">1.26.3.1.</span> <span class="nav-text">解法1.二分，复杂度$logn.maxflow(n+m,n+m)$</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#POJ-3155-Hard-Life"><span class="nav-number">1.26.3.2.</span> <span class="nav-text">POJ-3155 Hard Life</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E9%83%A8%E5%88%86"><span class="nav-number">1.26.4.</span> <span class="nav-text">模板部分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#dinic"><span class="nav-number">1.26.4.1.</span> <span class="nav-text">dinic</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dijkstra%E8%B4%B9%E7%94%A8%E6%B5%81"><span class="nav-number">1.26.4.2.</span> <span class="nav-text">dijkstra费用流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BF%E8%B4%B9%E7%94%A8%E6%B5%81"><span class="nav-number">1.26.4.3.</span> <span class="nav-text">BF费用流</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E5%81%B6%E5%9B%BE%E6%9C%80%E5%B0%8F%E5%89%B2"><span class="nav-number">1.26.5.</span> <span class="nav-text">对偶图最小割</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="nav-number">1.26.6.</span> <span class="nav-text">最大流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%AA%E7%A9%BA%E9%A3%9E%E8%A1%8C%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98%EF%BC%88%E6%9C%80%E5%B0%8F%E5%89%B2-%E6%94%B6%E7%9B%8A%E6%9C%80%E5%A4%A7%E9%97%AE%E9%A2%98%EF%BC%89"><span class="nav-number">1.26.6.1.</span> <span class="nav-text">太空飞行计划问题（最小割,收益最大问题）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98-%E6%9C%80%E5%A4%A7%E6%B5%81-%E6%9C%80%E5%B0%8F%E4%B8%8D%E7%9B%B8%E4%BA%A4%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E6%A8%A1%E5%9E%8B-%E8%A6%81%E6%B1%82%E8%B7%AF%E5%BE%84%E6%95%B0%E6%9C%80%E5%B0%91-%E8%B7%AF%E5%BE%84%E8%BE%93%E5%87%BA"><span class="nav-number">1.26.6.2.</span> <span class="nav-text">最小路径覆盖问题(最大流,最小不相交路径覆盖模型,要求路径数最少,路径输出)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#P2774-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E9%97%AE%E9%A2%98-%E6%9C%80%E5%A4%A7%E6%B5%81%EF%BC%8C%E6%9C%80%E5%B0%8F%E5%89%B2"><span class="nav-number">1.26.6.3.</span> <span class="nav-text">P2774 方格取数问题(最大流，最小割)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%B9%E7%94%A8%E6%B5%81"><span class="nav-number">1.26.7.</span> <span class="nav-text">费用流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#P4012-%E6%B7%B1%E6%B5%B7%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%97%AE%E9%A2%98%EF%BC%88%E7%89%A9%E5%93%81%E5%9C%A8%E7%BD%91%E6%A0%BC%E4%B8%8A%EF%BC%89"><span class="nav-number">1.26.7.1.</span> <span class="nav-text">P4012 深海机器人问题（物品在网格上）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#P3356-%E7%81%AB%E6%98%9F%E6%8E%A2%E9%99%A9%E9%97%AE%E9%A2%98%EF%BC%88%E7%89%A9%E5%93%81%E5%9C%A8%E4%BA%A4%E5%8F%89%E7%82%B9%E4%B8%8A%EF%BC%89"><span class="nav-number">1.26.7.2.</span> <span class="nav-text">P3356 火星探险问题（物品在交叉点上）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#P2604-%E6%89%A9%E5%AE%B9%E8%B4%B9%E7%94%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.26.7.3.</span> <span class="nav-text">P2604 扩容费用问题 </span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Overstars"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">Overstars</p>
  <div class="site-description" itemprop="description">这个人非常的菜</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Oversatrs" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Oversatrs" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:Overstars@foxmail.com" title="E-Mail → mailto:Overstars@foxmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/Oversatrs" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;Oversatrs" rel="noopener me" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/Miaplacidus" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;Miaplacidus" rel="noopener me" target="_blank"><i class="fab fa-solid fa-c fa-fw"></i>CSDN</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/24/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E7%9B%B8%E5%85%B3/%E7%8E%B0%E5%9C%A8%E7%BB%B4%E6%8A%A4%E7%9A%84%E6%A8%A1%E6%9D%BF/%E5%9B%BE%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Overstars">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="零岛">
      <meta itemprop="description" content="这个人非常的菜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="图论代码模板 | 零岛">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          图论代码模板
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
  
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-24 15:43:37" itemprop="dateCreated datePublished" datetime="2021-06-24T15:43:37+08:00">2021-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-27 21:21:17" itemprop="dateModified" datetime="2023-01-27T21:21:17+08:00">2023-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" itemprop="url" rel="index"><span itemprop="name">算法模板</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>这里记录了图论方面平时个人常用的代码模板。</p>
<span id="more"></span>

<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h3><ul>
<li>简单图：不含有平行边和自环的图。</li>
<li>多重图：含有平行边（同向）的图。</li>
<li>完全图：每一对节点之间都有边的简单图，$n$个节点无向完全图记为$K_n$。</li>
<li>平面图：能将所有点和边画在平面上，且边与边不相交的<strong>无向</strong>图。</li>
<li>补图：由$G$中<strong>所有节点</strong>和所有能使$G$成为完全图的<strong>添加边</strong>组成的图。</li>
<li>生成子图(Spanning Subgraph)：含有原图$G$中所有结点的子图。</li>
<li>图同构的<strong>必要条件</strong>：<ol>
<li>节点数相同。</li>
<li>边数相同。</li>
<li>度数相同的结点数相同。</li>
</ol>
</li>
</ul>
<h4 id="网络流常用概念"><a href="#网络流常用概念" class="headerlink" title="网络流常用概念"></a>网络流常用概念</h4><ul>
<li>连通图：只有一个连通分支（极大连通子图）的图。</li>
<li>割点：无向连通图中一个顶点$v$,，若删除它以及关联的边后，得到的新图至少包含两个连通分支。</li>
<li>桥：无向连通图中的一条边$e$，删除它得到的新图包含两个连通分量。</li>
<li>团(Clique)：原图$G$的一个<strong>完全</strong>子图。</li>
<li>极大团(Maximal Clique)：不是其它团的子图的团。</li>
<li>最大团(Maximum Clique)：顶点最多的极大团。</li>
<li>诱导子图(Induced Subgraph)：所有节点在原图$G$上连接的边都被包含在内的子图。</li>
<li>独立集：在图上选出一些节点，这些<strong>节点间两两无边</strong>的点集。</li>
<li>路径覆盖：在图中找一些路径，这些路径覆盖图中所有的顶点，每个顶点都只与一条路径相关联。</li>
<li>最小染色数：用最少的颜色个数给点染色且任意两点相邻点颜色不同，最少的颜色个数。</li>
</ul>
<h4 id="弦图常用概念"><a href="#弦图常用概念" class="headerlink" title="弦图常用概念"></a>弦图常用概念</h4><ul>
<li>弦：连接环上两个不相邻节点的边。</li>
<li>弦图：图上任意一个点数大于三的环都至少存在一条弦的无向图。</li>
<li>单纯点：节点$v$与相邻节点的诱导子图是一个团。</li>
<li>完美消除序列：有$n$个点的排列$v_1,v_2,\dots,v_n$，该排列满足$v_i$在${v_i,v_{i+1},\dots,v_n}$的诱导子图中是一个单纯点。</li>
<li><strong>一个无向图是弦图当且仅当它有一个完美消除序列</strong></li>
</ul>
<h3 id="常见结论"><a href="#常见结论" class="headerlink" title="常见结论"></a>常见结论</h3><ul>
<li>每个图中节点<strong>度数和</strong>等于边数的二倍，$\sum\limits_{v\in V} deg(v)&#x3D;2\left| E \right|$。</li>
<li>任何图中度数为奇数的节点必定有偶数个。</li>
<li>完全图$K_n$的边数$&#x3D;\frac{n(n-1)}{2}$</li>
<li>最大团中顶点数量 &#x3D; 补图的最大独立集中顶点数量</li>
<li>最大团数 ≤ 最小染色数，最大独立集 ≤ 最小团覆盖</li>
<li>弦图中：最大团数 &#x3D; 最小染色数，最大独立集 &#x3D; 最小团覆盖</li>
<li>平面图边数$m\le 3n-6$。</li>
</ul>
<h3 id="弦图"><a href="#弦图" class="headerlink" title="弦图"></a>弦图</h3><h4 id="最大势算法求消除序列并判定弦图"><a href="#最大势算法求消除序列并判定弦图" class="headerlink" title="最大势算法求消除序列并判定弦图"></a>最大势算法求消除序列并判定弦图</h4><p>判断一个消除序列是否为完美消除序列：从后向前枚举序列中的点$v_i$，设序列中在$v_i$后且与$v_i$相邻的点集<strong>依次</strong>为${v_{j1},v_{j2},\dots,v_{jk}}$，判断$v_j1$是否与${v_{j2},\dots,v_{jk}}$相邻即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,nex;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> v=<span class="number">0</span>,<span class="type">int</span> n=<span class="number">-1</span>):</span><br><span class="line">        <span class="built_in">v</span>(v),<span class="built_in">nex</span>(n)&#123;&#125;</span><br><span class="line">&#125; e[maxn*maxn];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>,head[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].v=v;</span><br><span class="line">    e[cnt].nex=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> label[maxn],id[maxn],order[maxn];<span class="comment">//id[i]表示节点i在序列中的编号</span></span><br><span class="line"><span class="type">bool</span> vis[maxn];<span class="comment">//order[i]为完美消除序列第i个节点,label[x]表示x点与多少个已标号节点相邻</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec[maxn];<span class="comment">//vec[x]存储*与x个已标号节点相邻*的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mcs</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//节点数量</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//复杂度O(n+m)</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(label,<span class="number">0</span>,<span class="built_in">sizeof</span>(label));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        vec[<span class="number">0</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="type">int</span> maxx=<span class="number">0</span>,now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;<span class="comment">//从前往后,每轮必定会找出一个</span></span><br><span class="line">        <span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=vec[maxx].<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;<span class="comment">//从后往前找</span></span><br><span class="line">                <span class="keyword">if</span>(vis[vec[maxx][j]])<span class="comment">//该节点已经标记过</span></span><br><span class="line">                    vec[maxx].<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;<span class="comment">//找到个未访问的节点</span></span><br><span class="line">                    now=vec[maxx][j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">                maxx--;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[now]=<span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">        order[n-i+<span class="number">1</span>]=now;</span><br><span class="line">        id[now]=n-i+<span class="number">1</span>;<span class="comment">//节点x在序列中的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=head[now];~j;j=e[j].nex)</span><br><span class="line">        &#123;<span class="comment">//遍历与now节点相邻的节点</span></span><br><span class="line">            <span class="type">int</span> v=e[j].v;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                label[v]++;<span class="comment">//v节点与已标号节点数++</span></span><br><span class="line">                vec[label[v]].<span class="built_in">push_back</span>(v);</span><br><span class="line">                maxx=<span class="built_in">max</span>(maxx,label[v]);<span class="comment">//找出最大的那个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> bucket[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isperfect</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//复杂度O(n+m)</span></span><br><span class="line">    <span class="built_in">mcs</span>(n);<span class="comment">//计算消除序列并判断是否为完美消除序列</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));<span class="comment">//判断序列中的点v_i是否与其后所有点相接</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">0</span>;i--)<span class="comment">//序列从后向前</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tot=<span class="number">0</span>,ret=<span class="number">1</span>;<span class="comment">//每轮桶清空</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=head[order[i]];~j;j=e[j].nex)</span><br><span class="line">            <span class="keyword">if</span>(id[e[j].v]&gt;i)<span class="comment">//排在序列编号x后面与x相邻的点集记为:N(x)</span></span><br><span class="line">                vis[bucket[++tot]=e[j].v]=<span class="number">1</span>;<span class="comment">//序列中x后且与x邻接点标记并放入桶中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=head[bucket[<span class="number">1</span>]];~j;j=e[j].nex)<span class="comment">//buc[1]的id为N(x)中最小？</span></span><br><span class="line">        &#123;<span class="comment">//bucket[1]=0...</span></span><br><span class="line">            <span class="type">int</span> v=e[j].v;</span><br><span class="line">            <span class="keyword">if</span>(v!=bucket[<span class="number">1</span>]&amp;&amp;vis[v])</span><br><span class="line">            &#123;<span class="comment">//判断N(x)中排在最前面的点是否与N(x)其他点相邻</span></span><br><span class="line">                ret++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tot;j++)</span><br><span class="line">            vis[bucket[j]]=<span class="number">0</span>;<span class="comment">//防止每次memset超时</span></span><br><span class="line">        <span class="keyword">if</span>(tot&amp;&amp;ret!=tot)<span class="comment">//不全部邻接</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,u,v;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n&amp;&amp;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(order,<span class="number">0</span>,<span class="built_in">sizeof</span>(order));</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            vec[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            <span class="built_in">add</span>(u,v);</span><br><span class="line">            <span class="built_in">add</span>(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;(<span class="built_in">isperfect</span>(n)?<span class="string">&quot;Perfect\n\n&quot;</span>:<span class="string">&quot;Imperfect\n\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三元环"><a href="#三元环" class="headerlink" title="三元环"></a>三元环</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>对原无向图进行定向，对任何一条边，从度数大的点连向度数小的点，如果度数相同，从编号小的点连向编号大的点。得到一个有向无环图。</li>
<li>枚举每一个节点$u$，将$u$所有相邻节点打上$u$的标记。再枚举$u$的相邻节点$v$，枚举$v$的相邻节点的相邻节点$w$，如果$w$上有被标记为$u$，则$(u,v,w)$就是一个三元环。</li>
</ol>
<p>统计图上三元环数量，复杂度$O(m\sqrt{m})$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector G[maxn];<span class="comment">//新图</span></span><br><span class="line"><span class="type">int</span> vis[maxn],deg[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cycle3</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:edges)</span><br><span class="line">    &#123;<span class="comment">//统计原无向图度数</span></span><br><span class="line">        deg[e.u]++;</span><br><span class="line">        deg[e.v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:edges)<span class="comment">//建立新图</span></span><br><span class="line">        <span class="keyword">if</span>(deg[e.u]&lt;deg[e.v]||(deg[e.u]==deg[e.v]&amp;&amp;e.u&lt;e.v))</span><br><span class="line">            G[e.u].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(e.u,e.v));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            G[e.v].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(e.v,e.u));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:G[u])</span><br><span class="line">            vis[v]=u;<span class="comment">//相邻节点打上u的标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:G[u])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> w:G[v])</span><br><span class="line">                <span class="keyword">if</span>(vis[w]==u)</span><br><span class="line">                    ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><h4 id="Dijkstra堆优化"><a href="#Dijkstra堆优化" class="headerlink" title="Dijkstra堆优化"></a>Dijkstra堆优化</h4><p>复杂度$O(ElgE)$，稠密图中有时不如普通版优秀，但比SPFA快。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1050</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qnode</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,c;</span><br><span class="line">    <span class="built_in">qnode</span>(<span class="type">int</span> _v=<span class="number">0</span>,<span class="type">int</span> _c=<span class="number">0</span>):<span class="built_in">v</span>(_v),<span class="built_in">c</span>(_c)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> qnode &amp;r)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c&gt;r.c;<span class="comment">//重载运算符&lt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,cost;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> _v=<span class="number">0</span>,<span class="type">int</span> _cost=<span class="number">0</span>):<span class="built_in">v</span>(_v),<span class="built_in">cost</span>(_cost)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt;E[MAXN];<span class="comment">//使用前必须清空0~n</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> dist[MAXN];<span class="comment">//到这个点的最近队员的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> start)</span><span class="comment">//传入总数及起点</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//点的编号从 1 开始</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        dist[i]=inf;</span><br><span class="line">    priority_queue&lt;qnode&gt;que;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">    dist[start]=<span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">qnode</span>(start,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        qnode now=que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> u=now.v;</span><br><span class="line">        <span class="keyword">if</span>(vis[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E[u].<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=E[u][i].v;</span><br><span class="line">            <span class="type">int</span> cost=E[u][i].cost;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v]&amp;&amp;dist[v]&gt;dist[u]+cost)&#123;</span><br><span class="line">                dist[v]=dist[u]+cost;</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">qnode</span>(v,dist[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[u].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v,w));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h4><p>最坏复杂度$O(VE)$，V为节点数，不适用于稠密图</p>
<p>检测负环：当存在一个点入队大于等于$V$次，则有负环</p>
<h5 id="BFS实现（求最短路）"><a href="#BFS实现（求最短路）" class="headerlink" title="BFS实现（求最短路）"></a>BFS实现（求最短路）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>,MAXN=<span class="number">5051</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w,next;</span><br><span class="line">&#125; e[MAXN];</span><br><span class="line"><span class="type">int</span> cnt,dist[MAXN],head[MAXN],num[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span><span class="comment">//链式前向星存图,无向则双向添加</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[cnt].v=v;<span class="comment">//边的结尾节点</span></span><br><span class="line">    e[cnt].w=w;</span><br><span class="line">    e[cnt].next=head[u];<span class="comment">//去找以u为起始的上一个节点(相当于链表,起始为-1)</span></span><br><span class="line">    head[u]=cnt++;<span class="comment">//保存该边(最后的边)在e[i]中的编号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> x)</span><span class="comment">//节点数量n,起点编号x</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,inf,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line">    dist[x]=<span class="number">0</span>;<span class="comment">//该题起点任意</span></span><br><span class="line">    num[x]++;<span class="comment">//入队次数++</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; QAQ;</span><br><span class="line">    QAQ.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(!QAQ.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=QAQ.<span class="built_in">front</span>();</span><br><span class="line">        QAQ.<span class="built_in">pop</span>();</span><br><span class="line">        vis[now]=<span class="number">0</span>;<span class="comment">//从队列中取出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i!=<span class="number">-1</span>;i=e[i].next)</span><br><span class="line">        &#123;<span class="comment">//遍历以now开头的所有边,尝试以x-&gt;now-&gt;to松弛x-&gt;to</span></span><br><span class="line">            <span class="type">int</span> to=e[i].v;<span class="comment">//尝试松弛x-&gt;to的当前距离</span></span><br><span class="line">            <span class="keyword">if</span>(dist[to]&gt;dist[now]+e[i].w)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[to]=dist[now]+e[i].w;<span class="comment">//成功用x-&gt;now-&gt;to松弛x-&gt;to</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[to])<span class="comment">//x-&gt;to被成功松弛且to不在队列</span></span><br><span class="line">                &#123;</span><br><span class="line">                    vis[to]=<span class="number">1</span>;<span class="comment">//标记to加入队列</span></span><br><span class="line">                    QAQ.<span class="built_in">push</span>(to);</span><br><span class="line">                    num[to]++;<span class="comment">//to加入队列次数++</span></span><br><span class="line">                    <span class="keyword">if</span>(num[to]&gt;n)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//有负权回路,无法求最短路径</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="DFS优化（负环检测）"><a href="#DFS优化（负环检测）" class="headerlink" title="DFS优化（负环检测）"></a>DFS优化（负环检测）</h5><p>请先用前向星加边。因为图有可能不连通，检测负环要枚举每个起点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//DFS优化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(dist[v]&gt;dist[x]+e[i].w)<span class="comment">//求最短路</span></span><br><span class="line">        &#123;</span><br><span class="line">            dist[v]=dist[x]+e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(vis[v])<span class="comment">//存在一点在一条路径上出现多次，存在负权环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">spfa</span>(v))<span class="comment">//搜到了存在负权环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//未找到负权环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线段树优化建图"><a href="#线段树优化建图" class="headerlink" title="线段树优化建图"></a>线段树优化建图</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">    <span class="built_in">edge</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> v,<span class="type">int</span> w):</span><br><span class="line">        <span class="built_in">v</span>(v),<span class="built_in">w</span>(w)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> edge &amp;y)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w&gt;y.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt;G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">adde</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(v,w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一棵树占4n的空间</span></span><br><span class="line"><span class="type">int</span> n,shift;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;<span class="comment">//是叶子,向真正节点连边,双向0权</span></span><br><span class="line">        <span class="built_in">adde</span>(x,l+<span class="number">2</span>*shift,<span class="number">0</span>);<span class="comment">//合并出树叶子与原点</span></span><br><span class="line">        <span class="built_in">adde</span>(l+<span class="number">2</span>*shift,x,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">adde</span>(x+shift,l+<span class="number">2</span>*shift,<span class="number">0</span>);<span class="comment">//合并点与入树叶子</span></span><br><span class="line">        <span class="built_in">adde</span>(l+<span class="number">2</span>*shift,x+shift,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">adde</span>(x&lt;&lt;<span class="number">1</span>,x,<span class="number">0</span>);<span class="comment">//出树,儿子向父亲建0权边,[l,r]-&gt;u</span></span><br><span class="line">    <span class="built_in">adde</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,<span class="number">0</span>);<span class="comment">//右儿子-&gt;父</span></span><br><span class="line">    <span class="built_in">adde</span>(x+shift,x*<span class="number">2</span>+shift,<span class="number">0</span>);<span class="comment">//入树,父亲向儿子建0权边,u-&gt;[l,r]</span></span><br><span class="line">    <span class="built_in">adde</span>(x+shift,x*<span class="number">2</span>+<span class="number">1</span>+shift,<span class="number">0</span>);<span class="comment">//父-&gt;右儿子</span></span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);<span class="comment">//左子树</span></span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);<span class="comment">//右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> nl,<span class="type">int</span> nr,<span class="type">int</span> x,<span class="type">int</span> w,<span class="type">bool</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl&gt;r||nr&lt;l)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=nl&amp;&amp;nr&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(in)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">adde</span>(x+<span class="number">2</span>*shift,p+shift,w);<span class="comment">//入树,x-&gt;[l,r]</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">adde</span>(p,x+<span class="number">2</span>*shift,w);<span class="comment">//[l,r]-&gt;x;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(nl+nr)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">add</span>(p&lt;&lt;<span class="number">1</span>,l,r,nl,mid,x,w,in);</span><br><span class="line">    <span class="built_in">add</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,mid+<span class="number">1</span>,nr,x,w,in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dist[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>*shift;i++)</span><br><span class="line">        dist[i]=INF;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n+<span class="number">2</span>*shift+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    priority_queue&lt;edge&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">edge</span>(s,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        edge now=q.<span class="built_in">top</span>();</span><br><span class="line">        <span class="type">int</span> x=now.v;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        dist[x]=now.w;</span><br><span class="line">        <span class="keyword">for</span>(edge &amp;i:G[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i.v]&amp;&amp;dist[i.v]&gt;dist[x]+i.w)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i.v]=dist[x]+i.w;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">edge</span>(i.v,dist[i.v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">signed</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q,s,ope,u,v,w,l,r;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q&gt;&gt;s;</span><br><span class="line">    shift=<span class="number">4</span>*n;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);<span class="comment">//先对于in树和out树建边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;ope;</span><br><span class="line">        <span class="keyword">if</span>(ope==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            <span class="built_in">adde</span>(u+<span class="number">2</span>*shift,v+<span class="number">2</span>*shift,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ope==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;l&gt;&gt;r&gt;&gt;w;<span class="comment">//x-&gt;[l,r]</span></span><br><span class="line">            <span class="built_in">add</span>(<span class="number">1</span>,l,r,<span class="number">1</span>,n,u,w,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;l&gt;&gt;r&gt;&gt;w;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">1</span>,l,r,<span class="number">1</span>,n,u,w,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>(s+<span class="number">2</span>*shift);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cout&lt;&lt;(dist[i+<span class="number">2</span>*shift]==INF?<span class="number">-1</span>:dist[i+<span class="number">2</span>*shift])&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * https://www.luogu.com.cn/problem/CF786B</span></span><br><span class="line"><span class="comment"> * n个点的有向带权图,有三种连有向边</span></span><br><span class="line"><span class="comment"> * 1.u到v</span></span><br><span class="line"><span class="comment"> * 2.u到点[l,r]都有一条边</span></span><br><span class="line"><span class="comment"> * 3.[l,r]到v都有一条边</span></span><br><span class="line"><span class="comment"> * 问从s出发的全局最短路</span></span><br><span class="line"><span class="comment"> * 建图肯定不能暴力建图...</span></span><br><span class="line"><span class="comment"> * https://www.luogu.com.cn/blog/_post/262486</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> path[<span class="number">805</span>][<span class="number">805</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//节点编号1~n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(path[i][k]+path[k][j]&lt;path[i][j])</span><br><span class="line">                &#123;<span class="comment">//当i，j的原来的边的最短距离，大于经过k点所到达的距离就替换</span></span><br><span class="line">                    path[i][j]=path[i][k]+path[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Floyd求最小环"><a href="#Floyd求最小环" class="headerlink" title="Floyd求最小环"></a>Floyd求最小环</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[maxn][maxn],mp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,u,v,d;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            dp[i][j]=mp[i][j]=(i==j?<span class="number">0</span>:inf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;d;</span><br><span class="line">        dp[u][v]=dp[v][u]=mp[u][v]=mp[v][u]=<span class="built_in">min</span>(dp[u][v],d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;<span class="comment">//i-&gt;k-&gt;j-&gt;i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i++)<span class="comment">//k为这个环上最大点,直接连接i与j</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;k;j++)<span class="comment">//dp[i][j]表示&lt;i,j&gt;只经过1~k-1优化的最短路</span></span><br><span class="line">                ans=<span class="built_in">min</span>(ans,dp[i][j]+mp[i][k]+mp[k][j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//如果经过k可以优化,那么它之前一定不经过k</span></span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==inf) cout&lt;&lt;<span class="string">&quot;No solution.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h3><h4 id="最大团大小"><a href="#最大团大小" class="headerlink" title="最大团大小"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4212">最大团大小</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">60</span>;</span><br><span class="line"><span class="type">int</span> G[maxn][maxn],tmp[maxn][maxn];<span class="comment">//tmp[i][j]搜到第i层</span></span><br><span class="line"><span class="type">int</span> n,ans,tot,f[maxn];<span class="comment">//Bron-Kerbosch 算法,复杂度3^n</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt;stk,rec;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> dep,<span class="type">int</span> num)</span><span class="comment">//深度(团大小),备选集合大小num</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//当前层数dep,num表示与当前层相邻的比</span></span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep&gt;ans)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=dep;</span><br><span class="line">            rec=stk;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep+num-i+<span class="number">1</span>&lt;=ans)<span class="comment">//剪枝1,不会超过当前最优解</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> v=tmp[dep][i];</span><br><span class="line">        <span class="keyword">if</span>(dep+f[v]&lt;=ans)<span class="comment">//剪枝f[v]+已经取了的点仍不超过最优解</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=num;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> vv=tmp[dep][j];</span><br><span class="line">            <span class="keyword">if</span>(G[v][vv])</span><br><span class="line">                tmp[dep+<span class="number">1</span>][++cnt]=vv;</span><br><span class="line">        &#125;</span><br><span class="line">        stk.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(dep+<span class="number">1</span>,cnt))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxClique</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[n]=ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        tot=<span class="number">0</span>;<span class="comment">//以i为最小编号点的最大团</span></span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        stk.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(G[i][j])</span><br><span class="line">                tmp[<span class="number">1</span>][++tot]=j;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,tot);</span><br><span class="line">        f[i]=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//回溯法求最大团</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v))</span><br><span class="line">        G[u][v]=G[v][u]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">maxClique</span>(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>如果一个系统是由n个变量和<strong>m个约束条件</strong>组成，并且每个约束条件能够形成形如$x_i−x_j\le c_k$的形式，我们就称该系统为差分约束系统。</p>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>我们如果要求$x_n-x_1$的最大值，先将不等号方向统一，统一为$x_i−x_j\le c_k$形式时，从$x_j$向$x_i$连一条权值为$c_k$的边，跑从$x_1$到$x_n$的最短路，$dist(x_n)-dist(x_1)$即为所求答案。</p>
<p>如果求某两个变量的差的最小值（或者让一组解中最大值最小），那么将所有等式转换为$x_j−x_i\ge -c_k$，从$x_i$向$x_j$连一条权值为$-c_k$的边，跑最长路，$dist$数组即为此时的答案。</p>
<p>因为可能会出现负环，此时无解，所以要使用SPFA求解，建立一个超级源点并向所有点连一条$0$费用的单向边，最坏复杂度$O(nm)$。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1131D">CF1131D Gourmet choice</a>：留待研究，$x_i - x_j \ge c_k$的建图跑最长路。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1450E">CF1450E Capitalism</a>：连通图上$n$个点，有$m$个关系，关系可以视为边，有如下两种。询问是否存在一种方案，使得<strong>存在关系</strong>的两个边的值<strong>不相等</strong>，若存在则输出使图上最大权值最大化的方案。</p>
<ul>
<li><p>$x_u-x_v&#x3D;1$（拆成$x_u-x_v\le 1$与$x_v-x_u\le -1$两条）</p>
</li>
<li><p>$|x_u-x_v|&#x3D;1$（拆成$x_u-x_v\le 1$与$x_v-x_u\le 1$两条，并且枚举check不能相等）</p>
</li>
</ul>
<p>思路：要使权值最大化，跑最短路，因为不确定以哪个点为起点能使最大距离最大，所以以每个点为起点都跑一遍并记录。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;edge&gt;G[maxn];</span><br><span class="line">ll dist[maxn],ans=-inf,pos=<span class="number">0</span>;</span><br><span class="line">vector&lt;pii&gt;rec;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt;<span class="built_in">vis</span>(n+<span class="number">2</span>,<span class="literal">false</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">cnt</span>(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;QAQ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        dist[i]=INF;</span><br><span class="line">    QAQ.<span class="built_in">push</span>(st);</span><br><span class="line">    cnt[st]++;</span><br><span class="line">    dist[st]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!QAQ.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=QAQ.<span class="built_in">front</span>();</span><br><span class="line">        QAQ.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u]=<span class="number">0</span>;<span class="comment">//出队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:G[u])</span><br><span class="line">            <span class="keyword">if</span>(dist[e.v]&gt;dist[u]+e.w)</span><br><span class="line">            &#123;<span class="comment">//最短路,因为要求最大值</span></span><br><span class="line">                dist[e.v]=dist[u]+e.w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[e.v])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(++cnt[e.v]&gt;n+<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    vis[e.v]=<span class="number">1</span>;</span><br><span class="line">                    QAQ.<span class="built_in">push</span>(e.v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(pii &amp;i:rec)<span class="comment">//没有羡慕,无解</span></span><br><span class="line">        <span class="keyword">if</span>(dist[i.ff]==dist[i.ss])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(dist[i]&gt;ans)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=dist[i];</span><br><span class="line">            pos=st;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">signed</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,u,v,w;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        <span class="keyword">if</span>(w==<span class="number">1</span>)<span class="comment">//u羡慕v,x_v=x_u+1</span></span><br><span class="line">        &#123;</span><br><span class="line">            G[u].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(v,<span class="number">1</span>));</span><br><span class="line">            G[v].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(u,<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//不知道谁羡慕谁</span></span><br><span class="line">            G[u].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(v,<span class="number">1</span>));</span><br><span class="line">            G[v].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(u,<span class="number">1</span>));</span><br><span class="line">            rec.<span class="built_in">push_back</span>(<span class="built_in">pii</span>(u,v));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">spfa</span>(n,i))</span><br><span class="line">            <span class="keyword">return</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl,<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">spfa</span>(n,pos);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cout&lt;&lt;dist[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树(MST)"></a>最小生成树(MST)</h3><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>复杂度：邻接矩阵:$O(V^2)$，邻接表:$O(ElogV)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>,maxn=<span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> dist[maxn][maxn],closest[maxn],lowcost[maxn];</span><br><span class="line"><span class="type">bool</span> tree[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> u0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in">sizeof</span>(tree));</span><br><span class="line">    tree[u0]=<span class="number">1</span>;<span class="comment">//加入树</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//① 初始化,</span></span><br><span class="line">        <span class="keyword">if</span>(i!=u0)&#123;</span><br><span class="line">            lowcost[i]=dist[u0][i];</span><br><span class="line">            closest[i]=u0;<span class="comment">//一开始只有u0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lowcost[u0]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//② 每次选出来一个最近的节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp=inf,t;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//③ 在V-u中寻找最近的节点t</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tree[j]&amp;&amp;lowcost[j]&lt;temp)</span><br><span class="line">            &#123;<span class="comment">//在剩下的节点找一个最近的</span></span><br><span class="line">                t=j;</span><br><span class="line">                temp=lowcost[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==u0)<span class="comment">//找不到t,没有可加入的节点,跳出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        tree[t]=<span class="number">1</span>;<span class="comment">//找到了就加入tree</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//④ 根据加入的t节点更新lowcost和closest</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tree[j]&amp;&amp;dist[t][j]&lt;lowcost[j])</span><br><span class="line">            &#123;<span class="comment">//对于剩下的节点维护</span></span><br><span class="line">                lowcost[j]=dist[t][j];</span><br><span class="line">                closest[j]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans+=lowcost[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><p>使用并查集优化，复杂度$O(mlogm)$</p>
<p>这个不能忘吧……就先不贴了</p>
<h4 id="Boruvka"><a href="#Boruvka" class="headerlink" title="Boruvka"></a>Boruvka</h4><p>因为没有$kruskal$好写，所以一般不用于MST裸题。</p>
<p>适于处理<strong>边权由连接的两个点的点权通过某种计算方式得出</strong>的情况。</p>
<p>平均 $O(V+E)$，最坏 $O((V+E)logV)$。 </p>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ol>
<li><p>对每个连通块，处理出与其他连通块连接的最小代价，并记录这条边。</p>
</li>
<li><p>连接所有连通块与其最小连接代价的连通块，并将该边边权计入。</p>
</li>
<li><p>若剩余连通块数量大于1，重复上述步骤。</p>
</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; E;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">boruvka</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//n个连通块</span></span><br><span class="line">        fa[i]=i;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cost</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">rec</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(E.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            cost[i]=inf;<span class="comment">//初始化为inf</span></span><br><span class="line">        <span class="type">int</span> cur=<span class="number">0</span>;<span class="comment">//统计不同连通块</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a=<span class="built_in">findfa</span>(E[i].u),b=<span class="built_in">findfa</span>(E[i].v),w=E[i].w;</span><br><span class="line">            <span class="keyword">if</span>(a==b)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            cur++;<span class="comment">//记录a,b两个连通块连接的最小代价</span></span><br><span class="line">            <span class="keyword">if</span>(w&lt;cost[a])</span><br><span class="line">                cost[a]=w,rec[a]=i;<span class="comment">//记录最小联通代价与相应边</span></span><br><span class="line">            <span class="keyword">if</span>(w&lt;cost[b])</span><br><span class="line">                cost[b]=w,rec[b]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;<span class="comment">//最坏情况是连接的连通块数目/2</span></span><br><span class="line">            <span class="keyword">if</span>(cost[i]&lt;inf&amp;&amp;!vis[rec[i]])<span class="comment">//与i相接的权值最小的边未加入</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Merge</span>(E[rec[i]].u,E[rec[i]].v);<span class="comment">//连接两个连通块</span></span><br><span class="line">                ans+=E[rec[i]].w;</span><br><span class="line">                vis[rec[i]]=<span class="literal">true</span>;<span class="comment">//标记该边已加入,避免重复计算</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h4><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P1550">打井问题 </a>：将地下水源缩成一个点，添加到图中，建立MST。</p>
</li>
<li><p>无根MDST：建立超级源点s，向每一个节点连接一条值为INF的边，以s为根跑MDST，s的出边即为答案MDST的树根。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF888G">异或生成树</a>：字典树合并连通块</p>
</li>
</ul>
<h4 id="CF888G-Xor-MST-异或生成树"><a href="#CF888G-Xor-MST-异或生成树" class="headerlink" title="CF888G Xor-MST 异或生成树"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF888G">CF888G Xor-MST 异或生成树</a></h4><h5 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h5><p>$n$节点无向完全图，每个点有点权$a_i$，连接点$i$与点$j$的边的边权为$a_i \oplus a_j$，求这个图的MST的权值，$1\le n \le 2\times 10^5, 0\le a_i \le 2^{30}$。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>异或最值问题，套一个trie，如果对这个套路不熟悉，请先做<a target="_blank" rel="noopener" href="http://codeforces.com/problemset/problem/923/C">CF923C Perfect Security</a>。<br>虽然已经没了Borůvka的形但是思想还在。<br>首先我们对所有点权排序并去重，因为相同的值异或为0，在图中必然是这些点相连且没有贡献，所以我们不用考虑这部分。<br>将剩下的点权插入trie，从根节点到叶子的一条路径就代表一个点权，叶子结点的数量就代表点权的数量。<br>初始时每个叶子都代表一个连通块，求解这个问题就是不断连接这些连通块的过程。<br>对于trie上的节点$x$，如果其左右子树都存在，那么就必须找一条边连接其左右子树，若$x$的所处位数为$w$，则这条边必有$1&lt;&lt;w$的贡献，对于$w$之前的位数，因为$x$到根节点路径相同异或值都为0；对于$[w-1,0]$的位数，这部分的贡献要对trie进行搜索来得到。<br>此时$x$左右子树已经联通，回溯继续向上处理即可。<br>$check$最坏情况下一次遍历整个trie树，$O(nlogn)$，最多合并$nlogn$次。<br>整体时间复杂度$O(nlog^2n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>,mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">200005</span>, M = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> val[maxn],trie[maxn&lt;&lt;<span class="number">5</span>][M],siz[maxn&lt;&lt;<span class="number">5</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> <span class="type">int</span> key)</span><span class="comment">//rt传入0</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//trie插入模式串</span></span><br><span class="line">    <span class="type">int</span> rt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id = (key&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[rt][id])</span><br><span class="line">            trie[rt][id]=tot++;</span><br><span class="line">        rt = trie[rt][id];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span><span class="comment">//启发式,最多向下2^w次?，但最多1e5个节点</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在x子树和y子树上求得一个最小异或值</span></span><br><span class="line">    ll ret=LLONG_MAX;</span><br><span class="line">    <span class="keyword">if</span>(trie[x][<span class="number">0</span>]&amp;&amp;trie[y][<span class="number">0</span>])<span class="comment">//尽量先使高位相同</span></span><br><span class="line">        ret=<span class="built_in">min</span>(ret,<span class="built_in">check</span>(trie[x][<span class="number">0</span>],trie[y][<span class="number">0</span>],w<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">if</span>(trie[x][<span class="number">1</span>]&amp;&amp;trie[y][<span class="number">1</span>])</span><br><span class="line">        ret=<span class="built_in">min</span>(ret,<span class="built_in">check</span>(trie[x][<span class="number">1</span>],trie[y][<span class="number">1</span>],w<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">if</span>(ret==LLONG_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(trie[x][<span class="number">0</span>]&amp;&amp;trie[y][<span class="number">1</span>])<span class="comment">//w位此时一定为1了</span></span><br><span class="line">            ret=<span class="built_in">min</span>(ret,<span class="built_in">check</span>(trie[x][<span class="number">0</span>],trie[y][<span class="number">1</span>],w<span class="number">-1</span>))+(<span class="number">1</span>&lt;&lt;w);</span><br><span class="line">        <span class="keyword">if</span>(trie[x][<span class="number">1</span>]&amp;&amp;trie[y][<span class="number">0</span>])</span><br><span class="line">            ret=<span class="built_in">min</span>(ret,<span class="built_in">check</span>(trie[x][<span class="number">1</span>],trie[y][<span class="number">0</span>],w<span class="number">-1</span>))+(<span class="number">1</span>&lt;&lt;w);</span><br><span class="line">        <span class="keyword">if</span>(ret==LLONG_MAX)<span class="comment">//说明两边没有节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> w)</span><span class="comment">//节点x开始搜索,右数第w位</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//从高位向下dfs</span></span><br><span class="line">    <span class="keyword">if</span>(w&lt;<span class="number">0</span>)<span class="comment">//只有根节点为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(trie[x][<span class="number">0</span>]&amp;&amp;trie[x][<span class="number">1</span>])<span class="comment">//都存在,找最小边连接两个连通块</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;w)+<span class="built_in">check</span>(trie[x][<span class="number">0</span>],trie[x][<span class="number">1</span>],w<span class="number">-1</span>)+<span class="built_in">dfs</span>(trie[x][<span class="number">0</span>],w<span class="number">-1</span>)+<span class="built_in">dfs</span>(trie[x][<span class="number">1</span>],w<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(trie[x][<span class="number">0</span>])<span class="comment">//左面存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(trie[x][<span class="number">0</span>],w<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//右面存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(trie[x][<span class="number">1</span>],w<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;val[i];</span><br><span class="line">    <span class="built_in">sort</span>(val+<span class="number">1</span>,val+n+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">unique</span>(val+<span class="number">1</span>,val+n+<span class="number">1</span>)-val<span class="number">-1</span>;<span class="comment">//去重是因为相同值异或为0,没必要再计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">Insert</span>(val[i]);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">30</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h3><h4 id="严格次小生成树-洛谷P4180"><a href="#严格次小生成树-洛谷P4180" class="headerlink" title="严格次小生成树(洛谷P4180)"></a>严格次小生成树(洛谷P4180)</h4><p>建立最小生成树MST，倍增维护MST上任一点到LCA最大值与次大值。</p>
<p>记录树的重量val，并对边集中选中边进行标记。倍增算出每个节点到祖先的路径最大边与严格次大边权值。枚举每一条不在MST上的的边u-&gt;v(权值w)，分别计算新树上u-&gt;lca(u,v)与v-&gt;lca(u,v)的路径<strong>最大边权M</strong>与<strong>严格次大边权m</strong>，记录<strong>最小非零</strong>增量inc&#x3D;w-M(当M&#x3D;&#x3D;w时inc&#x3D;w-m)。最后val+inc即为次小生成树重量。</p>
<p>复杂度瓶颈在排序，$O(mlogm)$</p>
<h3 id="有向图最小生成树（MDST，最小树形图）"><a href="#有向图最小生成树（MDST，最小树形图）" class="headerlink" title="有向图最小生成树（MDST，最小树形图）"></a>有向图最小生成树（MDST，最小树形图）</h3><ul>
<li><p>树形图：有向图$G&#x3D;(V,E)$中，选定根节点$root$，$G$的一个以$root$为根节点的子图$T$，$T$中$root$到任意其他节点路径<strong>存在且唯一</strong>。则$T$称为有向图生成树&#x2F;树形图DST。</p>
</li>
<li><p>最小树形图：带权有向图$G&#x3D;(V,E,w)$中边权总和最小的DST，即Minimum Directed Spanning Trees。</p>
</li>
<li><p>特点：</p>
<ul>
<li>MDST上一定有且仅有$n-1$条边</li>
<li>根节点入度为0，其他节点入度为1</li>
</ul>
</li>
</ul>
<h4 id="朱刘算法（Edmonds-算法）"><a href="#朱刘算法（Edmonds-算法）" class="headerlink" title="朱刘算法（Edmonds 算法）"></a>朱刘算法（Edmonds 算法）</h4><h5 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h5><ol>
<li>对每个非根节点，找出权值最小的入边（n-1条），记为集合$E$。若$E$不存在，则MDST一定不存在。</li>
<li>判断E中是否成环，成环转到步骤3，否则转到步骤4。</li>
<li>若成环则进行<strong>缩点</strong>，同时更新指向该环的所有边的权值，此更新等效于删去环上的一条边。<ul>
<li>记该环为$C$，在新图$G_1$中收缩为点$u$，则对于在$G$图中不在环上的且指向该环上任一点$v$的一条边$&lt;v_1,v&gt;$，该边权值记为$w$，在$G_1$中存在边$&lt;v_1,u&gt;$与之对应，且该边权值$W_{G_1}(&lt;v_1,u&gt;)$&#x3D;$W_{G}(&lt;v_1,v&gt;)-w$。</li>
<li>因为任何一个节点入度都不会大于1，在环$C$上已经为点$v$选择了一条入边，所以要根据改边权值更新其他点$v$入边权值，当接下来选择了其他指向$v$的边时，相当于删去了$C$上指向$v$的边。</li>
<li>转到步骤1，直到证明不存在或者求得。</li>
</ul>
</li>
<li>不成环则展开收缩点，获得MDST。若仅须获得MDST的权值，则不需要展开。</li>
</ol>
<h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><p>朱刘算法，不包括展开部分，未优化，复杂度$O(VE)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1005</span>,inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w):</span><br><span class="line">        <span class="built_in">u</span>(u),<span class="built_in">v</span>(v),<span class="built_in">w</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; G;<span class="comment">//该算法会修改边</span></span><br><span class="line"><span class="type">int</span> id[maxn],in[maxn],pre[maxn],vis[maxn];<span class="comment">//in[x]表示x入边最小权,pre[x]表示x最小入边的出点</span></span><br><span class="line"><span class="function">ll <span class="title">zltree</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> n)</span><span class="comment">//id[x]为x节点在G图上的编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fill</span>(in,in+n+<span class="number">1</span>,inf);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:G)</span><br><span class="line">            <span class="keyword">if</span>(e.u!=e.v&amp;&amp;e.w&lt;in[e.v])</span><br><span class="line">            &#123;</span><br><span class="line">                pre[e.v]=e.u;<span class="comment">//记录最小入边出点</span></span><br><span class="line">                in[e.v]=e.w;<span class="comment">//记录最小入边权</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(i!=root&amp;&amp;in[i]==inf)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//存在非根点没有入边,无MDST</span></span><br><span class="line">        <span class="built_in">fill</span>(id,id+n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="type">int</span> tn=<span class="number">0</span>,v;<span class="comment">//tn记录环的数量</span></span><br><span class="line">        in[root]=<span class="number">0</span>;<span class="comment">//根节点无入边,权为0(这样不用特判)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//找环</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans+=in[v=i];<span class="comment">//加v入边贡献</span></span><br><span class="line">            <span class="keyword">while</span>(vis[v]!=i&amp;&amp;!id[v]&amp;&amp;v!=root)<span class="comment">//</span></span><br><span class="line">                vis[v]=i,v=pre[v];<span class="comment">//检查v的最小入边出点,并标记vis为i</span></span><br><span class="line">            <span class="keyword">if</span>(v!=root&amp;&amp;!id[v])</span><br><span class="line">            &#123;</span><br><span class="line">                id[v]=++tn;<span class="comment">//标记环的编号</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> u=pre[v];u!=v;u=pre[u])</span><br><span class="line">                    id[u]=tn;<span class="comment">//将v所在环打上同一个标记</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tn==<span class="number">0</span>)<span class="comment">//无环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(!id[i])<span class="comment">//给不在环上的点新编号</span></span><br><span class="line">                id[i]=++tn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)G.<span class="built_in">size</span>();)<span class="comment">//更新为新图G1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;e=G[i];</span><br><span class="line">            v=e.v;</span><br><span class="line">            e.u=id[e.u],e.v=id[e.v];</span><br><span class="line">            <span class="keyword">if</span>(e.u!=e.v)<span class="comment">//更新指向环的边权</span></span><br><span class="line">                e.w-=in[v],i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(e,G.<span class="built_in">back</span>());</span><br><span class="line">                G.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n=tn;<span class="comment">//更新新图的点数</span></span><br><span class="line">        root=id[root];<span class="comment">//更新新图上根节点编号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,r,u,v,w;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;r;<span class="comment">//n节点,m条边,根节点r</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        G.<span class="built_in">push_back</span>(<span class="built_in">edge</span>(u,v,w));<span class="comment">//有向</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">zltree</span>(r,n)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kruskal重构树"><a href="#kruskal重构树" class="headerlink" title="kruskal重构树"></a>kruskal重构树</h3><img src="https://img2020.cnblogs.com/blog/1596795/202009/1596795-20200927163453949-799155444.png" style="zoom:50%;">

<p>用于求解无向有权图上任意两点$u$到$v$间选择一条路线，使最大边最小化，求该最大边的值。</p>
<p>该值即为$kruskal$重构树上$u$与$v$节点的权值，最小化最大边求值同理。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)<span class="comment">//一定要初始化2n</span></span><br><span class="line">    fa[i]=i;</span><br><span class="line"><span class="type">int</span> tot=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:E)</span><br><span class="line">&#123;<span class="comment">//E为排好序的边集</span></span><br><span class="line">    <span class="type">int</span> a=<span class="built_in">findfa</span>(e.u),b=<span class="built_in">findfa</span>(e.v);</span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    fa[a]=fa[b]=++tot;<span class="comment">//合并并查集</span></span><br><span class="line">    val[tot]=e.w;<span class="comment">//新lca的权值</span></span><br><span class="line">    G[tot].<span class="built_in">push_back</span>(a);<span class="comment">//新节点指向原来并查集的根</span></span><br><span class="line">    G[tot].<span class="built_in">push_back</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">init</span>(tot,tot);<span class="comment">//处理重构树lca</span></span><br><span class="line">cin&gt;&gt;q;</span><br><span class="line"><span class="keyword">while</span>(q--)</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">    cout&lt;&lt;val[<span class="built_in">lca</span>(u,v)]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="矩阵树定理"><a href="#矩阵树定理" class="headerlink" title="矩阵树定理"></a>矩阵树定理</h3><p>无向图$G$的生成树个数等于其<strong>基尔霍夫矩阵</strong>任何一个$n-1$阶<strong>主子式</strong>的行列式的绝对值（或者任意一个1阶子式的代数余子式）。</p>
<p>基尔霍夫矩阵$K$&#x3D;度数矩阵$D$−邻接矩阵$A$。<br>$$<br>D_{ij}&#x3D;\begin{cases}deg(v_i)&amp;,v_i&#x3D;v_j\0&amp;,v_i\ne v_j \end{cases}，A_{ij}&#x3D;\begin{cases}1&amp;,v_i与v_j相接\0&amp;,v_i不与v_j相接 \end{cases}，K_{ij}&#x3D; \begin{cases}deg(v_i)&amp;,i&#x3D;j\-1&amp;,v_i与v_j相接\0&amp;,v_i与v_j不相接\end{cases}<br>$$</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Kirchhoff</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//传入基尔霍夫矩阵及其阶数</span></span><br><span class="line">    n--;<span class="comment">//删去最后一行和最后一列</span></span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//高斯消元求解行列式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">while</span>(Kir[j][i])</span><br><span class="line">            &#123;</span><br><span class="line">                ll tmp=Kir[i][i]/Kir[j][i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=n;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Kir[i][k]=(Kir[i][k]-tmp*Kir[j][k]%mod+mod)%mod;</span><br><span class="line">                    std::<span class="built_in">swap</span>(Kir[j][k],Kir[i][k]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans=-ans;</span><br><span class="line">            &#125;</span><br><span class="line">        ans=(ans*Kir[i][i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans+mod)%mod;<span class="comment">//得到生成树个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>外向树：所有边的方向都是从根指向叶子。<br>内向树：所有边的方向都是从叶子指向根。</p>
<ol>
<li>内向生成树个数：将度数矩阵换成点的入度。</li>
<li>外向生成树个数：将度数矩阵换成点的出度。</li>
</ol>
<h3 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h3><p>虚树是在树形dp中使用的一种特殊优化，适用于树中仅有<strong>少量关键节点</strong>且普通节点很多的情况。可以将关键点和他们的LCA拿出来另建一棵树，并在这棵树上另外进行树形dp。</p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>在原树上进行dfs，进行LCA预处理，同时得到原树上的dfs序，方便之后虚树构造，此外还可以进行一些dp预处理，便于进行虚树上的第二次dp。</li>
<li>确定关键节点集合，并按照dfs序排序。</li>
<li>通过单调栈及LCA算法构建出虚树。</li>
<li>在虚树上进行树形dp求解。</li>
</ol>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(h+<span class="number">1</span>,h+k+<span class="number">1</span>,[](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> dfn[x]&lt;dfn[y];<span class="comment">//按dfs序排序</span></span><br><span class="line">&#125;);</span><br><span class="line">stk[top=<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//指定1为根,否则可以指定h[1]</span></span><br><span class="line">g[<span class="number">1</span>].<span class="built_in">clear</span>();<span class="comment">//奇怪的清空优化1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)<span class="comment">//k个重要节点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> now=h[i];</span><br><span class="line">    <span class="type">int</span> lc=<span class="built_in">lca</span>(now,stk[top]);<span class="comment">//最近公共祖先</span></span><br><span class="line">    <span class="comment">//printf(&quot;lca(%d,%d)=%d\n&quot;,now,stk[top],lc);</span></span><br><span class="line">    <span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;dfn[lc]&lt;=dfn[stk[top<span class="number">-1</span>]])<span class="comment">//情况4,=是情况3</span></span><br><span class="line">    &#123;<span class="comment">//不断将top送入虚树</span></span><br><span class="line">        <span class="built_in">adde</span>(stk[top<span class="number">-1</span>],stk[top]);<span class="comment">//前向星加边,构建新树</span></span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[lc]&lt;dfn[stk[top]])<span class="comment">//情况2</span></span><br><span class="line">    &#123;<span class="comment">//加边,top出栈,lc和now入栈</span></span><br><span class="line">        g[lc].<span class="built_in">clear</span>();<span class="comment">//奇怪的清空优化2</span></span><br><span class="line">        <span class="built_in">adde</span>(lc,stk[top]);</span><br><span class="line">        stk[top]=lc;</span><br><span class="line">    &#125;<span class="comment">//否则为情况1</span></span><br><span class="line">    g[now].<span class="built_in">clear</span>();<span class="comment">//奇怪的清空优化3</span></span><br><span class="line">    stk[++top]=now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(--top)</span><br><span class="line">    <span class="built_in">adde</span>(stk[top],stk[top+<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF613D">CF613D Kingdom and its Cities</a>：清空虚树优化</li>
</ul>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>只适用于DAG。</p>
<p>使用队列（要求字典序时使用优先队列），在邻接表存边时统计每个结点的入度，入度为0则入队。按出队顺序编号，删除以该节点为尾的边，该边边头<strong>入度减1</strong>，若变为0则入队。直到队列为空，得到top数组与node数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">105</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxn];</span><br><span class="line"><span class="type">int</span> n,m,top[maxn],node[maxn];<span class="comment">//节点i拓扑顺序为top[i]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//要求字典序：优先队列，小根堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; QAQ;<span class="comment">//若要求字典序用优先队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(G[i][<span class="number">0</span>]==<span class="number">0</span>)<span class="comment">//G[i][0]表示入度</span></span><br><span class="line">            QAQ.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!QAQ.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=QAQ.<span class="built_in">top</span>();</span><br><span class="line">        top[x]=++cnt;<span class="comment">//top[x]表示x号节点的次序编号</span></span><br><span class="line">        QAQ.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;G[x].<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(--G[G[x][i]][<span class="number">0</span>]==<span class="number">0</span>)<span class="comment">//节点入度为0时入队</span></span><br><span class="line">                QAQ.<span class="built_in">push</span>(G[x][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt!=n)<span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        node[top[i]]=i;<span class="comment">//node[i]表示排序为i的节点为node[i]</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//        printf(&quot;%d%c&quot;,node[i],i&lt;n?&#x27; &#x27;:&#x27;\n&#x27;);//输出拓扑排序后的节点</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&amp;&amp;(n||m))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            G[i].<span class="built_in">clear</span>();<span class="comment">//注意清空</span></span><br><span class="line">            G[i].<span class="built_in">push_back</span>(<span class="number">0</span>);<span class="comment">//G[i][0]用来统计节点i的入度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> u,v;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            G[u].<span class="built_in">push_back</span>(v);<span class="comment">//向G中加边</span></span><br><span class="line">            G[v][<span class="number">0</span>]++;<span class="comment">//v的入度+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">topsort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补图搜索"><a href="#补图搜索" class="headerlink" title="补图搜索"></a>补图搜索</h3><p>也是很套路的题了，使用$set$数组来代替邻接表，用$set.find(v)$来确定边是否在图中。并查集、DFS、BFS都可以做。</p>
<h4 id="补图连通块-0-1-MST"><a href="#补图连通块-0-1-MST" class="headerlink" title="补图连通块 0-1 MST "></a>补图连通块 <a target="_blank" rel="noopener" href="https://codeforc.es/contest/1243/problem/D">0-1 MST </a></h4><p>初始化$ans&#x3D;0$，并将所有的点放进一个未访问集合$unvis$中，当集合非空时，取出$unvis.begin()$记为$now$并从集合中去掉，并从该点开始BFS，遍历$nuvis$集，并在邻接表$set[now]$中查询，若$set.find()$未找到，则说明该边为补边。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; G[maxn];<span class="comment">//使用set存原图,加快速度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; unvis;<span class="comment">//已访问节点,从原图上删除</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        unvis.<span class="built_in">insert</span>(i);<span class="comment">//将所有点加入到nuvis集合中</span></span><br><span class="line">    <span class="keyword">while</span>(!unvis.<span class="built_in">empty</span>())<span class="comment">//BFS求连通块个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans++;<span class="comment">//从未访问集里拿出新的元素,新增一个连通块</span></span><br><span class="line">        <span class="type">int</span> now=*(unvis.<span class="built_in">begin</span>());<span class="comment">//取出第一个</span></span><br><span class="line">        unvis.<span class="built_in">erase</span>(now);</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; QwQ;</span><br><span class="line">        QwQ.<span class="built_in">push</span>(now);</span><br><span class="line">        <span class="keyword">while</span>(!QwQ.<span class="built_in">empty</span>())<span class="comment">//找出与now联通的节点,并从unvis中删去</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nex=QwQ.<span class="built_in">front</span>();<span class="comment">//与now联通的点之一</span></span><br><span class="line">            QwQ.<span class="built_in">pop</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v1;<span class="comment">//记录要删去的节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:unvis)<span class="comment">//遍历未访问集合</span></span><br><span class="line">                <span class="keyword">if</span>(G[nex].<span class="built_in">find</span>(i)==G[nex].<span class="built_in">end</span>())</span><br><span class="line">                &#123;<span class="comment">//now与i由补边连接,权重为0</span></span><br><span class="line">                    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    QwQ.<span class="built_in">push</span>(i);<span class="comment">//放进队列里,继续向下求联通点</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v1.<span class="built_in">size</span>();i++)</span><br><span class="line">                unvis.<span class="built_in">erase</span>(v1[i]);<span class="comment">//在集合中删去搜到的联通节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="欧拉路"><a href="#欧拉路" class="headerlink" title="欧拉路"></a>欧拉路</h3><p>给定一张联通无向&#x2F;有向图，求一条经过所有边恰好一次的回路。</p>
<p> 有解当且仅当所有点 <strong>度数为偶数(无向)</strong>&#x2F;**入度等于出度(有向)**。 任选一点开始dfs，每条边只经过一次。回溯时将回溯的边加入队列，最后队列的逆序就是答案。 时间复杂度$O(m)$。<br>欧拉路径也可以用一样的方法求出（找度数为奇数的点进行DFS）。</p>
<h4 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h4><ul>
<li>无向图欧拉回路：所有点度数都为偶数</li>
<li>有向图欧拉回路：所有点入度&#x3D;出度</li>
<li>无向图欧拉路：有0或2个点度数为奇数，其余点度数为偶数</li>
<li>有向图欧拉路：一个点入度&#x3D;出度+1，一个点出度&#x3D;入度+1，其余点入度&#x3D;出度</li>
</ul>
<h4 id="Hierholzer算法"><a href="#Hierholzer算法" class="headerlink" title="Hierholzer算法"></a>Hierholzer算法</h4><p>待补…</p>
<h4 id="两笔画问题"><a href="#两笔画问题" class="headerlink" title="两笔画问题"></a>两笔画问题</h4><p>有解当且仅当入度为奇数的点不超过四个。 将其中两个点加一条边后求欧拉路径，然后在这条边处断开成两条欧拉路即可。 时间复杂度$O(m)$。</p>
<h3 id="汉密尔顿回路"><a href="#汉密尔顿回路" class="headerlink" title="汉密尔顿回路"></a>汉密尔顿回路</h3><h4 id="求简单无向图的环数"><a href="#求简单无向图的环数" class="headerlink" title="求简单无向图的环数"></a>求简单无向图的环数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">19</span>,inf=<span class="number">0x3f3f3f3f</span>,mod=<span class="number">1000000007</span>;</span><br><span class="line">ll dp[<span class="number">1ll</span>&lt;&lt;maxn][maxn],ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;G[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">signed</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,u,v;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        u--,v--;<span class="comment">//现在是[0,18]了</span></span><br><span class="line">        G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp[k][x]表示当前点为x,前面经过点的状态为k的简单路径条数</span></span><br><span class="line">    <span class="comment">//且经过的第一个点是k二进制下第一位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        dp[<span class="number">1ll</span>&lt;&lt;i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> lowbit(x) ((x) &amp; -(x))</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;(<span class="number">1ll</span>&lt;&lt;n);k++)</span><br><span class="line">    &#123;<span class="comment">//k为经过点的状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;<span class="built_in">x</span>&lt;n;x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[k][x])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> &amp;v:G[x])</span><br><span class="line">            &#123;<span class="comment">//枚举x相邻点v</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">lowbit</span>(k)&gt;(<span class="number">1ll</span>&lt;&lt;v))<span class="comment">//v小于经过第一个点,非法</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(k&amp;(<span class="number">1ll</span>&lt;&lt;v))<span class="comment">//x是已经过点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">lowbit</span>(k)==(<span class="number">1ll</span>&lt;&lt;v))<span class="comment">//是最早经过点,成环</span></span><br><span class="line">                        ans+=dp[k][x];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//未经过点,更新状态</span></span><br><span class="line">                    dp[k|(<span class="number">1ll</span>&lt;&lt;v)][v]+=dp[k][x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(ans-m)/<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h3><h4 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h4><h5 id="Tarjan缩点-DAG-拓扑排序dp"><a href="#Tarjan缩点-DAG-拓扑排序dp" class="headerlink" title="Tarjan缩点+DAG 拓扑排序dp"></a>Tarjan缩点+DAG 拓扑排序dp</h5><p>n个点m条边的<strong>有向图</strong>，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。</p>
<p>思路：使用<strong>Tarjan缩点</strong>建立新图DAG，在DAG上进行拓扑排序并进行DP。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> tot=<span class="number">0</span>,Index=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> stk[maxn],dfn[maxn],low[maxn],belong[maxn];</span><br><span class="line"><span class="type">int</span> val[maxn],rec[maxn];<span class="comment">//每个强连通分量的值</span></span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxn];<span class="comment">//邻接表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//标准的Tarjan缩点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++tim;<span class="comment">//dfs序</span></span><br><span class="line">    stk[++Index]=x;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;v:G[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])<span class="comment">//v未被访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[v]);<span class="comment">//回溯时更新low</span></span><br><span class="line">        &#125;<span class="comment">//low[x]为x所在强连通分量最早起始节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[v])<span class="comment">//v在栈中,说明有环</span></span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[v]);<span class="comment">//更新起点为最早的那个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[x]==dfn[x])</span><br><span class="line">    &#123;<span class="comment">//以x为起点的强连通分量</span></span><br><span class="line">        cnt++;<span class="comment">//新图节点++</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            belong[stk[Index]]=cnt;</span><br><span class="line">            rec[cnt]+=val[stk[Index]];<span class="comment">//缩点后的权值</span></span><br><span class="line">            vis[stk[Index]]=<span class="number">0</span>;</span><br><span class="line">            Index--;</span><br><span class="line">        &#125;<span class="keyword">while</span>(stk[Index+<span class="number">1</span>]!=x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; Gra[maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn],top[maxn],into[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">topsort</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; QAQ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!into[i])</span><br><span class="line">            QAQ.<span class="built_in">push</span>(i);</span><br><span class="line">        dp[i]=rec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!QAQ.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=QAQ.<span class="built_in">front</span>();</span><br><span class="line">        QAQ.<span class="built_in">pop</span>();</span><br><span class="line">        top[x]=++flag;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Gra[x].<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[Gra[x][i]]=<span class="built_in">max</span>(dp[Gra[x][i]],dp[x]+rec[Gra[x][i]]);</span><br><span class="line">            <span class="keyword">if</span>(--into[Gra[x][i]]==<span class="number">0</span>)</span><br><span class="line">                QAQ.<span class="built_in">push</span>(Gra[x][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;val[i];<span class="comment">//每个点的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//Tarjan缩点部分</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);<span class="comment">//缩点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//拓扑排序部分</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;G[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=belong[i],y=belong[G[i][j]];</span><br><span class="line">            <span class="keyword">if</span>(x!=y)</span><br><span class="line">            &#123;</span><br><span class="line">                Gra[x].<span class="built_in">push_back</span>(y);<span class="comment">//建立新图DAG</span></span><br><span class="line">                into[y]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">topsort</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="双连通分量-biconnected-component"><a href="#双连通分量-biconnected-component" class="headerlink" title="双连通分量(biconnected component)"></a>双连通分量(biconnected component)</h5><p>双连通分量概念： 双连通分量有点双连通分量和边双连通分量两种。若一个无向图中的去掉任意一个节点（一条边）都不会改变此图的连通性，即不存在割。</p>
<ul>
<li><p>割点：去掉这个点，原无向联通图不再联通。</p>
</li>
<li><p>割边&#x2F;桥：去掉这条边，原无向联通图不再联通。</p>
</li>
<li><p>点双连通：删掉一个<strong>点</strong>之后，图仍联通</p>
</li>
<li><p>边双连通：删掉一条<strong>边</strong>之后，图仍联通</p>
</li>
</ul>
<p>点双连通：在一个无向图中，若任意两点间至少存在两条“点不重复”的路径，则说这个图是<strong>点双连通的</strong>。点双连通的极大子图称为<strong>点双连通分量</strong>（简称<strong>双连通分量</strong>,Biconnected Component,<strong>BCC</strong>）。</p>
<p>点双连通图不存在<strong>割点</strong>的图，边双连通图即不存在<strong>桥</strong>的图。</p>
<ul>
<li>BCC中无割点，任意两点间至少存在两条点不重复的路径等价于图中删去任意一个点都不会改变图的连通性</li>
<li>若BCC间有公共点，则公共点为<strong>原图的割点</strong></li>
<li>无向连通图中<strong>割点一定属于至少两个BCC</strong>，非割点只属于一个BCC</li>
</ul>
<h6 id="点双连通分量缩点"><a href="#点双连通分量缩点" class="headerlink" title="点双连通分量缩点"></a>点双连通分量缩点</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dfn[maxn],low[maxn],stk[maxn],belong[maxn],index=<span class="number">0</span>,cnt=<span class="number">0</span>,tim=<span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;G[maxn],g[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[x]=dfn[x]=++tim;</span><br><span class="line">    vis[x]=<span class="number">1</span>;<span class="comment">//标记在栈中</span></span><br><span class="line">    stk[++index]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;v:G[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v,x);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[x]==dfn[x]&amp;&amp;vis[x])</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;<span class="comment">//双连通分量个数</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            belong[stk[index]]=cnt;</span><br><span class="line">            vis[stk[index]]=<span class="number">0</span>;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;<span class="keyword">while</span>(stk[index+<span class="number">1</span>]!=x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Tarjan无向图求割点"><a href="#Tarjan无向图求割点" class="headerlink" title="Tarjan无向图求割点"></a>Tarjan无向图求割点</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tot=<span class="number">0</span>,Index=<span class="number">0</span>,ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dfn[maxn],low[maxn],stk[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn],isc[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++tot;</span><br><span class="line">    <span class="type">int</span> child=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G[x].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=G[x][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v,x);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[v]);</span><br><span class="line">            <span class="keyword">if</span>(x==fa)</span><br><span class="line">                child++;</span><br><span class="line">            <span class="keyword">if</span>(x!=fa&amp;&amp;low[v]&gt;=dfn[x])</span><br><span class="line">                isc[x]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(v!=fa)<span class="comment">//不同之处</span></span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==fa&amp;&amp;child&gt;=<span class="number">2</span>)</span><br><span class="line">        isc[x]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="无向图求桥"><a href="#无向图求桥" class="headerlink" title="无向图求桥"></a>无向图求桥</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//</span></span><br><span class="line">    dfn[x]=low[x]=++tot;</span><br><span class="line">    <span class="type">bool</span> vis=<span class="number">0</span>;<span class="comment">//处理重边要加上,表示这个节点还没有被子树搜到</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G[x].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=G[x][i].v,no=G[x][i].no;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v,x);</span><br><span class="line">            <span class="keyword">if</span>(low[v]&gt;dfn[x])<span class="comment">//讨论桥是大于</span></span><br><span class="line">            &#123;</span><br><span class="line">                bri[no]=<span class="number">1</span>;<span class="comment">//法1，对桥的编号做标记</span></span><br><span class="line"><span class="comment">//                pair&lt;int,int&gt; tem;//法二，将桥存到新的数组中</span></span><br><span class="line"><span class="comment">//                tem.first=x,tem.second=v;</span></span><br><span class="line"><span class="comment">//                ans[flag++]=tem;</span></span><br><span class="line">            &#125;</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[x]&gt;dfn[v])<span class="comment">//可改为无条件？</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v==fa&amp;&amp;!vis)</span><br><span class="line">                vis=<span class="number">1</span>;<span class="comment">//除了第一次，每次回到父节点都用父节点的值更新当前结点的值</span></span><br><span class="line">            <span class="keyword">else</span><span class="comment">//之前是v!=fa时才用父节点值更新该点的值</span></span><br><span class="line">                low[x]=<span class="built_in">min</span>(low[x],dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-SAT问题"><a href="#2-SAT问题" class="headerlink" title="2-SAT问题"></a>2-SAT问题</h4><h5 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h5><ol>
<li>将点$i$拆成$i$与$n+i$两个点，分别表示点$i$状态为$0$或$1$，二者必须且只能取其一。</li>
<li>根据所给逻辑关系建图，将$2n$个点进行缩点。</li>
<li>若存在一对拆点位于同一个强连通分量，则无解。</li>
<li>否则对于每个点对，选择<strong>分量编号</strong>较小的点（即拓扑序较大的那个）。</li>
</ol>
<h5 id="建图方式"><a href="#建图方式" class="headerlink" title="建图方式"></a>建图方式</h5><table>
<thead>
<tr>
<th>逻辑表达式</th>
<th>连接的有向边(推导关系)</th>
</tr>
</thead>
<tbody><tr>
<td>$a&#x3D;1$,$a$单个点必为真，为假同理</td>
<td>$\lnot a \rightarrow a$</td>
</tr>
<tr>
<td>$a\land b&#x3D;1$</td>
<td>$\lnot a\rightarrow a,\lnot b \rightarrow b$</td>
</tr>
<tr>
<td>$a\land b&#x3D;0$</td>
<td>$a\rightarrow \lnot b,b \rightarrow \lnot a$</td>
</tr>
<tr>
<td>$a \lor b&#x3D;1$</td>
<td>$\lnot a\rightarrow b,\lnot b \rightarrow a$</td>
</tr>
<tr>
<td>$a \lor b&#x3D;0$</td>
<td>$a\rightarrow \lnot a,b \rightarrow \lnot b$</td>
</tr>
<tr>
<td>$a\oplus b&#x3D;1$</td>
<td>$\lnot a\rightarrow b,b \rightarrow \lnot a,\lnot b \rightarrow a,a\rightarrow \lnot b$</td>
</tr>
<tr>
<td>$a\oplus b&#x3D;0$，或$a\odot b&#x3D;1$</td>
<td>$a\rightarrow b,b\rightarrow a,\lnot a\rightarrow \lnot b,\lnot b\rightarrow \lnot a$</td>
</tr>
<tr>
<td>$a\rightarrow b$,$\lnot a \lor b$,为假当且仅当$a$为真$b$为假</td>
<td>$a\rightarrow b,\lnot b\rightarrow\lnot a$</td>
</tr>
<tr>
<td>$\lnot a\rightarrow\lnot b,a\lor \lnot b$</td>
<td>$\lnot a\rightarrow\lnot b,b\rightarrow a$</td>
</tr>
</tbody></table>
<h3 id="圆方树"><a href="#圆方树" class="headerlink" title="圆方树"></a>圆方树</h3><p>圆方树就是一种将图变成树的方法，可以处理仙人掌（每条<strong>边</strong>在不超过一个简单环中的无向图）。</p>
<p>顶点仙人掌：每个点不会在超过一个简单环中的联通无向图，其特点为缩点后每个点不会在超过两个BCC中。</p>
<p>在圆方树中，原来的每个<strong>点</strong>对应一<strong>个圆点</strong>，每一个<strong>点双</strong>对应一个<strong>方点</strong>。所以共有 $n+c$ 个点，其中 $n$ 是原图点数，$c$ 是原图点双连通分量的个数。如果原图有 $k$ 个<strong>连通分量</strong>，则它的圆方树也会形成 $k$ 棵树形成的森林。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> rst&#123;</span><br><span class="line">    <span class="type">int</span> siz[maxn&lt;&lt;<span class="number">1</span>],dfn[maxn],low[maxn],dfc=<span class="number">0</span>,stk[maxn],top=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> belong[maxn&lt;&lt;<span class="number">1</span>],cnt=<span class="number">0</span>,n;<span class="comment">//方点的个数</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;pg[maxn],G[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//点双缩点并建立圆方树</span></span><br><span class="line">        dfn[x]=low[x]=++dfc;<span class="comment">//初次访问x</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Enter: #%d,dfn=%d\n&quot;</span>,x,dfn[x]);</span><br><span class="line">        stk[++top]=x;<span class="comment">//入栈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:pg[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(v);</span><br><span class="line">                low[x]=std::<span class="built_in">min</span>(low[x],low[v]);<span class="comment">//未访问的和low</span></span><br><span class="line">                <span class="keyword">if</span>(low[v]==dfn[x])</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt++;<span class="comment">//增加方点个数/BCC个数</span></span><br><span class="line">                    <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;\nFind a new bcc #%d.\n&quot;</span>,cnt-n);</span><br><span class="line">                    <span class="keyword">do</span>&#123;<span class="comment">//点双中所有点向方点连边,除了x都退栈</span></span><br><span class="line">                        G[cnt].<span class="built_in">push_back</span>(stk[top]);<span class="comment">//</span></span><br><span class="line">                        G[stk[top]].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">                        siz[cnt]++;</span><br><span class="line">                        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Bcc #%d has vertex #%d.\n&quot;</span>,cnt-n,stk[top]);</span><br><span class="line">                        top--;</span><br><span class="line">                    &#125;<span class="keyword">while</span>(stk[top+<span class="number">1</span>]!=v);</span><br><span class="line">                    siz[cnt]++;</span><br><span class="line">                    G[cnt].<span class="built_in">push_back</span>(x);<span class="comment">//x自己连边,但不退栈</span></span><br><span class="line">                    G[x].<span class="built_in">push_back</span>(cnt);<span class="comment">//因为一个点可能在多个bcc中</span></span><br><span class="line">                    <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Bcc #%d has top vertex #%d\nsize = %d.\n&quot;</span>,cnt-n,x,siz[cnt]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low[x]=std::<span class="built_in">min</span>(low[x],dfn[v]);<span class="comment">//已访问的和dfn</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rst::n=cnt=n;<span class="comment">//初始有n个点</span></span><br><span class="line">        top=dfc=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(!dfn[i])<span class="comment">//tarjan退出时根仍在栈内</span></span><br><span class="line">                <span class="built_in">tarjan</span>(i),top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// namespace rst</span></span><br></pre></td></tr></table></figure>



<h3 id="最近公共祖先-LCA"><a href="#最近公共祖先-LCA" class="headerlink" title="最近公共祖先(LCA)"></a>最近公共祖先(LCA)</h3><p>因为LCA只适用于树，所以经常和生成树在一起考。</p>
<h4 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxl=<span class="number">30</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxn];<span class="comment">//无权边,也可以选择链式前向星存图</span></span><br><span class="line"><span class="type">int</span> gene[maxn][maxl],depth[maxn],lg[maxn];</span><br><span class="line"><span class="type">int</span> nodes[maxn];<span class="comment">//子树结点的数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    depth[x]=depth[fa]+<span class="number">1</span>;</span><br><span class="line">    gene[x][<span class="number">0</span>]=fa;</span><br><span class="line">    nodes[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=depth[x];i++)<span class="comment">//倍增</span></span><br><span class="line">        gene[x][i]=gene[gene[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G[x].<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">if</span>(G[x][i]!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(G[x][i],x);<span class="comment">//在dfs前后加语句可以求出许多有趣的东西</span></span><br><span class="line">            nodes[x]+=nodes[G[x][i]];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[x]&lt;depth[y])<span class="comment">//保证x深度≥y</span></span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">while</span>(depth[x]&gt;depth[y])<span class="comment">//将x提到同一高度</span></span><br><span class="line">        x=gene[x][lg[depth[x]-depth[y]<span class="number">-1</span>]];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="comment">//是同一个节点</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(gene[x][i]!=gene[y][i])</span><br><span class="line">        &#123;<span class="comment">//二分思想,直到跳到LCA的下面一层</span></span><br><span class="line">            x=gene[x][i];</span><br><span class="line">            y=gene[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> gene[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dist</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//x节点到y结点的距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tem=<span class="built_in">lca</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(<span class="built_in">abs</span>(depth[x]-depth[tem])+<span class="built_in">abs</span>(depth[y]-depth[tem]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(nodes,<span class="number">0</span>,<span class="built_in">sizeof</span>(nodes));</span><br><span class="line"><span class="comment">//    memset(gene,0,sizeof(gene));</span></span><br><span class="line">    depth[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//预处理出log2(i)+1的值</span></span><br><span class="line">        lg[i]=lg[i<span class="number">-1</span>]+((<span class="number">1</span>&lt;&lt;(lg[i<span class="number">-1</span>]+<span class="number">1</span>))==i);<span class="comment">//不要写错</span></span><br><span class="line">    <span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul>
<li><p>次小生成树：<a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P4180">P4180严格次小生成树</a></p>
</li>
<li><p>树上两条路径是否相交：<a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P3398">仓鼠找sugar </a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u=<span class="built_in">lca</span>(a,b),v=<span class="built_in">lca</span>(c,d);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dist</span>(u,c)+<span class="built_in">dist</span>(u,d)==<span class="built_in">dist</span>(c,d)||<span class="built_in">dist</span>(v,a)+<span class="built_in">dist</span>(v,b)==<span class="built_in">dist</span>(a,b))</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
</li>
<li><p>给定节点，求以它为LCA的节点有多少种组合：<a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P5002">找祖先 </a>，DFS回溯求出</p>
</li>
<li><p>分类讨论求树上到任意两点距离相等的点的个数（重点讨论中节点与LCA关系）：<a target="_blank" rel="noopener" href="https://www.luogu.org/problem/CF519E">A and B and Lecture Rooms </a></p>
</li>
<li><p>求两节点路径上最大&#x2F;最小边的权值，若求最小即为求容量：<a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P1967">货车运输 </a>，DFS时倍增求出路径上min</p>
</li>
</ul>
<h3 id="树上差分"><a href="#树上差分" class="headerlink" title="树上差分"></a>树上差分</h3><p>用于求解一些<strong>树上路径</strong>问题。</p>
<p>常见问法：将一棵树上从u到v路径上的<strong>点&#x2F;边</strong>的权值加上x，询问<strong>某点&#x2F;边</strong>的权值。</p>
<p>$O(1)$修改，$O(n)$查询，复杂度决定要离线。</p>
<p>强行在线可用<strong>树链剖分</strong>$O(\log n \times \log n)$修改，$O( \log n \times \log n)$查询。</p>
<p>修改差分数组之前先用DFS倍增求出各节点LCA。</p>
<p>差分数组记为power[maxn]，直接修改即可，查询时调用DFS</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul>
<li>树上任意两点之间有且只有一条路径</li>
<li>一个节点只有一个父节点</li>
<li>$x$节点到$y$结点的路线为：$x→lca(x,y)→y$</li>
</ul>
<h4 id="点的差分"><a href="#点的差分" class="headerlink" title="点的差分"></a>点的差分</h4><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>每次修改使$u$到$v$的路径上所有节点权值+1（包括端点），询问某一节点权值。</p>
<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>$power[u]++,\ power[v]++,\ power[lca(u,v)]–,\ power[father[lca(u,v)]]–$</p>
<h4 id="边的差分"><a href="#边的差分" class="headerlink" title="边的差分"></a>边的差分</h4><h5 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h5><p><strong>以点代边</strong>，$power[x]$代表$x$节点到父节点的边的权值。</p>
<p>若查询边的权值，则需要按输入顺序对每条边进行编号。</p>
<p>每次修改使节点$u$与节点$v$之间<strong>所有边</strong>权值+1，询问某一条边权值。</p>
<h5 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h5><p>$power[u]++,\ power[v]++,\ power[lca(u,v)]-&#x3D;2$</p>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> power[maxn];<span class="comment">//power[x]即为x节点权值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//查询，求出所有节点权值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=G[i].nex)<span class="comment">//枚举x所有子节点</span></span><br><span class="line">        <span class="keyword">if</span>(G[i].v!=gene[x][<span class="number">0</span>])<span class="comment">//不为x父节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(G[i].v);<span class="comment">//</span></span><br><span class="line">            power[x]+=power[G[i].v];</span><br><span class="line">        &#125;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,power[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h3><p>注意以点代边的思想</p>
<ul>
<li>功能<ol>
<li>更新&#x2F;查询某个节点子树的权值</li>
<li>更新&#x2F;查询树上两个节点间所有点的权值</li>
</ol>
</li>
<li>性质<ol>
<li>子树的时间戳一定全部小于父节点，并且连续（所以可用线段树维护）</li>
<li>任何一条路径都是由重链的一部分与重链间的叶子节点构成</li>
<li>任何父节点都一定在一条重链上（所以可用top的父节点跳链）</li>
</ol>
</li>
<li>例题<ol>
<li><a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P3384">P3384 树链剖分 </a></li>
</ol>
</li>
</ul>
<h4 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,tot=<span class="number">0</span>,head[maxn];</span><br><span class="line"><span class="type">double</span> val[maxn];<span class="comment">//给定的每个节点的权值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;<span class="comment">//边权一般不必记录到这里</span></span><br><span class="line">    <span class="type">int</span> v,nex;</span><br><span class="line">    ll w;</span><br><span class="line">&#125; e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,ll w=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].v=v;</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    e[tot].nex=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以点代边:以节点的权值代表该节点到父节点边的权值,修改与查询跳过链顶点即可(最终的参数改为dfn[x]+1)</span></span><br><span class="line"><span class="comment">//使用前先初始化,然后加边,dfs1(rt,rt),dfs2(rt,rt),build(1,1,n),使用封装好的函数修改+查询</span></span><br><span class="line"><span class="keyword">namespace</span> hld&#123;<span class="comment">//heavy-light decomposition</span></span><br><span class="line">    <span class="type">int</span> n,father[maxn],son[maxn],depth[maxn],siz[maxn];<span class="comment">//父节点,重儿子节点,深度,子树大小</span></span><br><span class="line">    <span class="type">int</span> tim=<span class="number">0</span>,dfn[maxn],rk[maxn],top[maxn];<span class="comment">//计数器,时间戳(节点编号),访问顺序,节点所在重链的顶部节点</span></span><br><span class="line">    <span class="keyword">using</span> type=<span class="type">long</span> <span class="type">long</span>;<span class="comment">//每个节点的类型</span></span><br><span class="line">    type w[maxn];<span class="comment">//节点dfs序对应权值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n=N;</span><br><span class="line"><span class="comment">//        cerr&lt;&lt;&quot;hld::n  = &quot;&lt;&lt;hld::n&lt;&lt;endl;</span></span><br><span class="line">        tim=tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(depth,<span class="number">0</span>,<span class="built_in">sizeof</span>(depth));</span><br><span class="line"><span class="comment">//        memset(father,0,sizeof(father));</span></span><br><span class="line">        <span class="built_in">memset</span>(son,<span class="number">0</span>,<span class="built_in">sizeof</span>(son));</span><br><span class="line"><span class="comment">//        memset(top,0,sizeof(top));</span></span><br><span class="line">        <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="built_in">sizeof</span>(dfn));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//预处理出深度,父节点,重儿子,子树大小</span></span><br><span class="line">        depth[x]=depth[fa]+<span class="number">1</span>;</span><br><span class="line">        father[x]=fa;</span><br><span class="line">        siz[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxsiz=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].nex)</span><br><span class="line">        &#123;<span class="comment">//遍历儿子节点</span></span><br><span class="line">            <span class="type">int</span> v=e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(v==fa)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//            val[v]=e[i].w;//以点代边:将边的权值赋给边头节点</span></span><br><span class="line"><span class="comment">//            fprintf(stderr,&quot;val[%lld]=%lld\n&quot;,v,val[v]);</span></span><br><span class="line">            <span class="built_in">dfs1</span>(v,x);</span><br><span class="line">            siz[x]+=siz[v];<span class="comment">//加上儿子的子树大小</span></span><br><span class="line">            <span class="keyword">if</span>(maxsiz&lt;siz[v])</span><br><span class="line">            &#123;</span><br><span class="line">                son[x]=v;</span><br><span class="line">                maxsiz=siz[v];<span class="comment">//记录重儿子</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//按dfs序对各节点重新编号,并记录对应权值到w数组</span></span><br><span class="line">        dfn[x]=++tim;<span class="comment">//记录dfs序</span></span><br><span class="line">        rk[tim]=x;<span class="comment">//记录访问节点的顺序,即dfn的反函数</span></span><br><span class="line">        top[x]=t;<span class="comment">//注意这里,top是在树外的</span></span><br><span class="line">        w[tim]=val[x];<span class="comment">//将x结点权值存到对应的时间戳</span></span><br><span class="line">        <span class="keyword">if</span>(!son[x])<span class="comment">//没有儿子</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(son[x],t);<span class="comment">//继续处理重儿子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].nex)<span class="comment">//处理其他儿子</span></span><br><span class="line">            <span class="keyword">if</span>(e[i].v!=father[x]&amp;&amp;e[i].v!=son[x])</span><br><span class="line">                <span class="built_in">dfs2</span>(e[i].v,e[i].v);<span class="comment">//开始另一条重链</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(depth[top[x]]&lt;depth[top[y]])</span><br><span class="line">                <span class="built_in">swap</span>(x,y);</span><br><span class="line">            x=father[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (depth[x]&gt;depth[y])?y:x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span><span class="comment">//线段树按dfs序维护树上路径权值部分</span></span><br><span class="line">    &#123;</span><br><span class="line">        type val,Max,lazy;</span><br><span class="line">    &#125; tree[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tree[root].val=tree[root&lt;&lt;<span class="number">1</span>].val+tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val;</span><br><span class="line">        tree[root].Max=<span class="built_in">max</span>(tree[root&lt;&lt;<span class="number">1</span>].Max,tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].Max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> root=<span class="number">1</span>,<span class="type">int</span> l=<span class="number">1</span>,<span class="type">int</span> r=n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tree[root].lazy=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="comment">//注意这里是l</span></span><br><span class="line">            tree[root].val=tree[root].Max=w[l];<span class="comment">//按时间戳顺序的数组</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(root&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">            <span class="built_in">build</span>(root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">            <span class="built_in">pushup</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[root].lazy)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            tree[root&lt;&lt;<span class="number">1</span>].val=tree[root&lt;&lt;<span class="number">1</span>].val+tree[root].lazy*(mid-l+<span class="number">1</span>);</span><br><span class="line">            tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val=tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val+tree[root].lazy*(r-mid);</span><br><span class="line">            tree[root&lt;&lt;<span class="number">1</span>].Max+=tree[root].lazy;<span class="comment">//子节点最大值也要+更新值</span></span><br><span class="line">            tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].Max+=tree[root].lazy;</span><br><span class="line">            tree[root&lt;&lt;<span class="number">1</span>].lazy+=tree[root].lazy;</span><br><span class="line">            tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy+=tree[root].lazy;</span><br><span class="line">            tree[root].lazy=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> nst,<span class="type">int</span> ned,<span class="type">int</span> ust,<span class="type">int</span> ued,type num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//区间更新</span></span><br><span class="line">        <span class="keyword">if</span>(ned&lt;ust||ued&lt;nst)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(ust&lt;=nst&amp;&amp;ued&gt;=ned)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[root].val=tree[root].val+(ned-nst+<span class="number">1</span>)*num;</span><br><span class="line">            tree[root].Max+=num;</span><br><span class="line">            tree[root].lazy+=num;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(root,nst,ned);</span><br><span class="line">        <span class="type">int</span> mid=(nst+ned)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">modify</span>(root&lt;&lt;<span class="number">1</span>,nst,mid,ust,ued,num);</span><br><span class="line">        <span class="built_in">modify</span>(root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,ned,ust,ued,num);</span><br><span class="line">        <span class="built_in">pushup</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">type <span class="title">query</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> nst,<span class="type">int</span> ned,<span class="type">int</span> qst,<span class="type">int</span> qed)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//查询区间和</span></span><br><span class="line">        <span class="keyword">if</span>(ned&lt;qst||qed&lt;nst)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(qst&lt;=nst&amp;&amp;ned&lt;=qed)</span><br><span class="line">            <span class="keyword">return</span> tree[root].val;</span><br><span class="line">        <span class="built_in">pushdown</span>(root,nst,ned);</span><br><span class="line">        <span class="type">int</span> mid=(nst+ned)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(root&lt;&lt;<span class="number">1</span>,nst,mid,qst,qed)+<span class="built_in">query</span>(root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,ned,qst,qed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">type <span class="title">qmax</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> nst,<span class="type">int</span> ned,<span class="type">int</span> qst,<span class="type">int</span> qed)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//查询区间和</span></span><br><span class="line">        <span class="keyword">if</span>(ned&lt;qst||qed&lt;nst)</span><br><span class="line">            <span class="keyword">return</span> LLONG_MIN;<span class="comment">//这里也要改成对应的MIN</span></span><br><span class="line">        <span class="keyword">if</span>(qst&lt;=nst&amp;&amp;ned&lt;=qed)</span><br><span class="line">            <span class="keyword">return</span> tree[root].Max;</span><br><span class="line">        <span class="built_in">pushdown</span>(root,nst,ned);</span><br><span class="line">        <span class="type">int</span> mid=(nst+ned)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">qmax</span>(root&lt;&lt;<span class="number">1</span>,nst,mid,qst,qed),<span class="built_in">qmax</span>(root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,ned,qst,qed));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下是开放的</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mson</span><span class="params">(<span class="type">int</span> x,type addnum,<span class="type">int</span> n=n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//将以x为根的子树全部加上一个数</span></span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[x]+siz[x]<span class="number">-1</span>,addnum);<span class="comment">//子树节点编号是连续的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> type <span class="title">sonsum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> n=n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//查询以x为根子树权值和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[x]+siz[x]<span class="number">-1</span>);<span class="comment">//同上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">type <span class="title">sonmax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> n=n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qmax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[x]+siz[x]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mchain</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,type addnum,<span class="type">int</span> n=n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(top[x]!=top[y])<span class="comment">//不在同一条链上时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(depth[top[x]]&lt;depth[top[y]])</span><br><span class="line">                <span class="built_in">swap</span>(x,y);<span class="comment">//保证x所在链顶部更低</span></span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x],addnum);<span class="comment">//更新顶部节点较低的重链(顶部节点到当前点部分)</span></span><br><span class="line">            x=father[top[x]];<span class="comment">//跳到链顶节点的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(depth[x]&gt;depth[y])<span class="comment">//直到最后在同一条重链上</span></span><br><span class="line">            <span class="built_in">swap</span>(x,y);<span class="comment">//此时保证x节点在y上面</span></span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[y],addnum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">type <span class="title">chainsum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> n=n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        type ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(depth[top[x]]&lt;depth[top[y]])</span><br><span class="line">                <span class="built_in">swap</span>(x,y);</span><br><span class="line">            ret+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x]);</span><br><span class="line">            x=father[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(depth[x]&gt;depth[y])</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="keyword">return</span> ret+<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">type <span class="title">chainmax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> n=n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        type ret=LLONG_MIN;<span class="comment">//注意这里改成对应的MIN</span></span><br><span class="line">        <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(depth[top[x]]&lt;depth[top[y]])</span><br><span class="line">                <span class="built_in">swap</span>(x,y);</span><br><span class="line">            ret=<span class="built_in">max</span>(ret,<span class="built_in">qmax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x]));</span><br><span class="line">            x=father[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(depth[x]&gt;depth[y])</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ret,<span class="built_in">qmax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[y]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="P3384-树链剖分"><a href="#P3384-树链剖分" class="headerlink" title="P3384 树链剖分 "></a><a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P3384">P3384 树链剖分 </a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> mod=<span class="number">100000007</span>;</span><br><span class="line"><span class="type">int</span> head[maxn],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,nex;</span><br><span class="line">&#125; e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> father[maxn],son[maxn];<span class="comment">//父节点,重儿子节点</span></span><br><span class="line"><span class="type">int</span> depth[maxn],siz[maxn],top[maxn];<span class="comment">//深度,子树大小,节点所在重链的顶部节点</span></span><br><span class="line"><span class="type">int</span> tim=<span class="number">0</span>,dfn[maxn],rk[maxn],w[maxn];<span class="comment">//计数器,时间戳(节点编号),访问顺序</span></span><br><span class="line"><span class="type">int</span> val[maxn];<span class="comment">//给定的每个节点的权值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].v=v;</span><br><span class="line">    e[cnt].nex=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    father[x]=fa;</span><br><span class="line">    depth[x]=depth[fa]+<span class="number">1</span>;</span><br><span class="line">    siz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> maxsize=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].nex)<span class="comment">//遍历儿子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,x);</span><br><span class="line">        siz[x]+=siz[v];<span class="comment">//加上儿子的子树大小</span></span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;maxsize)</span><br><span class="line">        &#123;</span><br><span class="line">            maxsize=siz[v];</span><br><span class="line">            son[x]=v;<span class="comment">//记录重儿子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> t)</span><span class="comment">//当前节点与重链顶节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x]=t;<span class="comment">//记录该节点所在重链的顶部节点</span></span><br><span class="line">    dfn[x]=++tim;<span class="comment">//记录该节点的访问时间(给节点编号,方便线段树操作)</span></span><br><span class="line">    rk[tim]=x;<span class="comment">//记录访问节点的顺序</span></span><br><span class="line">    w[tim]=val[x];<span class="comment">//将x结点权值存到对应的时间戳</span></span><br><span class="line">    <span class="keyword">if</span>(!son[x])</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//没有儿子</span></span><br><span class="line">    <span class="built_in">dfs2</span>(son[x],t);<span class="comment">//继续处理重儿子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].nex)</span><br><span class="line">    &#123;<span class="comment">//处理其他儿子</span></span><br><span class="line">        <span class="keyword">if</span>(e[i].v!=son[x]&amp;&amp;e[i].v!=father[x])</span><br><span class="line">            <span class="built_in">dfs2</span>(e[i].v,e[i].v);<span class="comment">//开始另一条重链</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val,lazy;</span><br><span class="line">&#125; tree[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[root].val=(tree[root&lt;&lt;<span class="number">1</span>].val+tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[root].val=tree[root].lazy=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="comment">//注意这里是l</span></span><br><span class="line">        tree[root].val=w[l]%mod;<span class="comment">//按时间戳顺序的数组</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(root&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        <span class="built_in">build</span>(root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[root].lazy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        tree[root&lt;&lt;<span class="number">1</span>].val=(tree[root&lt;&lt;<span class="number">1</span>].val%mod+(tree[root].lazy%mod*(mid-l+<span class="number">1</span>))%mod)%mod;</span><br><span class="line">        tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val=(tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val%mod+(tree[root].lazy%mod*(r-mid)%mod))%mod;</span><br><span class="line">        tree[root&lt;&lt;<span class="number">1</span>].lazy=(tree[root&lt;&lt;<span class="number">1</span>].lazy%mod+tree[root].lazy%mod)%mod;</span><br><span class="line">        tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy=(tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy%mod+tree[root].lazy%mod)%mod;</span><br><span class="line">        tree[root].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> nst,<span class="type">int</span> ned,<span class="type">int</span> ust,<span class="type">int</span> ued,<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ned&lt;ust||ued&lt;nst)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(ust&lt;=nst&amp;&amp;ued&gt;=ned)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[root].lazy=(tree[root].lazy%mod+num%mod)%mod;</span><br><span class="line">        tree[root].val=(tree[root].val%mod+((ned-nst+<span class="number">1</span>)%mod*(num%mod))%mod)%mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(root,nst,ned);</span><br><span class="line">    <span class="type">int</span> mid=(nst+ned)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">modify</span>(root&lt;&lt;<span class="number">1</span>,nst,mid,ust,ued,num);</span><br><span class="line">    <span class="built_in">modify</span>(root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,ned,ust,ued,num);</span><br><span class="line">    <span class="built_in">pushup</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> nst,<span class="type">int</span> ned,<span class="type">int</span> qst,<span class="type">int</span> qed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ned&lt;qst||qed&lt;nst)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(qst&lt;=nst&amp;&amp;qed&gt;=ned)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[root].val%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(root,nst,ned);</span><br><span class="line">    <span class="type">int</span> mid=(nst+ned)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">query</span>(root&lt;&lt;<span class="number">1</span>,nst,mid,qst,qed)+<span class="built_in">query</span>(root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,ned,qst,qed))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mson</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> n,<span class="type">int</span> addnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//将以x为根的子树全部加上一个数</span></span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[x]+siz[x]<span class="number">-1</span>,addnum);<span class="comment">//子树节点编号是连续的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qson</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[x]+siz[x]<span class="number">-1</span>)%mod;<span class="comment">//同上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mchain</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> n,<span class="type">int</span> addnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    addnum%=mod;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])<span class="comment">//不在同一条链上时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[top[x]]&lt;depth[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x,y);<span class="comment">//保证x所在链顶部更低</span></span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x],addnum);<span class="comment">//更新顶部节点较低的重链(顶部节点到当前点部分)</span></span><br><span class="line">        x=father[top[x]];<span class="comment">//跳到链顶节点的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(depth[x]&gt;depth[y])<span class="comment">//直到最后在同一条重链上</span></span><br><span class="line">        <span class="built_in">swap</span>(x,y);<span class="comment">//此时保证x节点在y上面</span></span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[y],addnum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qchain</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[top[x]]&lt;depth[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        ret=(ret+<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x]))%mod;</span><br><span class="line">        x=father[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(depth[x]&gt;depth[y])</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> (ret+<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[y]))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;P3384.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="type">int</span> n,m,p,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;r,&amp;mod);</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(r,r);</span><br><span class="line">    <span class="built_in">dfs2</span>(r,r);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ope,x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ope);</span><br><span class="line">        <span class="keyword">if</span>(ope==<span class="number">1</span>)</span><br><span class="line">        &#123;<span class="comment">//链x-&gt;y修改,全部加上z</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            <span class="built_in">mchain</span>(x,y,n,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ope==<span class="number">2</span>)</span><br><span class="line">        &#123;<span class="comment">//链x-&gt;y查询</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">qchain</span>(x,y,n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ope==<span class="number">3</span>)</span><br><span class="line">        &#123;<span class="comment">//x子树修改</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;z);</span><br><span class="line">            <span class="built_in">mson</span>(x,n,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//x子树查询</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">qson</span>(x,n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//        printf(&quot;%d:%d\n&quot;,i,tree[i].val);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *功能：</span></span><br><span class="line"><span class="comment"> *1.更新/查询某个节点子树的权值</span></span><br><span class="line"><span class="comment"> *2.更新/查询树上两个节点间所有点的权值</span></span><br><span class="line"><span class="comment"> *性质：</span></span><br><span class="line"><span class="comment"> *1.子树的时间戳一定全部小于父节点，并且连续</span></span><br><span class="line"><span class="comment"> *2.任何一条路径都是由重链的一部分与重链间的叶子节点构成</span></span><br><span class="line"><span class="comment"> *3.任何父节点都一定在一条重链上</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h3><h4 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h4><ul>
<li>也叫树的质心。找到一个点,其所有的子树中最大的子树节点数最少,那么这个点就是这棵树的重心,删去重心后，生成的多棵树尽可能平衡。</li>
</ul>
<h4 id="流程-3"><a href="#流程-3" class="headerlink" title="流程"></a>流程</h4><ol>
<li>找出当前树的重心<ul>
<li>因为分治步骤二需要将sum赋值为当前树大小(siz[v])，所以getrt要跑两遍</li>
</ul>
</li>
<li>处理经过中心的路径<ul>
<li>点分治运算的核心，经常会出现变形</li>
</ul>
</li>
<li>删除树的重心</li>
<li>对新得到的子树重复上述步骤</li>
</ol>
<h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p>一棵n节点的树，询问树上距离为k的点对是否存在。离线操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxk=<span class="number">10000005</span>;</span><br><span class="line"><span class="type">int</span> tot=<span class="number">0</span>,head[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,nex,w;</span><br><span class="line">&#125; e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].v=v;</span><br><span class="line">    e[tot].nex=head[u];</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,root,sum=<span class="number">0</span>;<span class="comment">//重心,sum当前大小</span></span><br><span class="line"><span class="type">int</span> siz[maxn],maxp[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getrt</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//DFS找重心</span></span><br><span class="line">    siz[x]=<span class="number">1</span>,maxp[x]=<span class="number">0</span>;<span class="comment">//maxp为最大子树大小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v==fa||vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getrt</span>(v,x);</span><br><span class="line">        siz[x]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;maxp[x])</span><br><span class="line">            maxp[x]=siz[v];<span class="comment">//记录下面的最大子树大小</span></span><br><span class="line">    &#125;<span class="comment">//无根树,sum-siz[x]为以x的父节点为根的大小</span></span><br><span class="line">    <span class="comment">//在以自身为根节点的子树大小和以x的父节点为根的大小中取较大的</span></span><br><span class="line">    maxp[x]=<span class="built_in">max</span>(maxp[x],sum-siz[x]);<span class="comment">//sum为整棵树的大小</span></span><br><span class="line">    <span class="keyword">if</span>(maxp[x]&lt;maxp[root])</span><br><span class="line">        root=x;<span class="comment">//最大子树最小的点为重心</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dist[maxn],tmp[maxn],cnt=<span class="number">0</span>;<span class="comment">//cnt计数器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getdist</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//DFS求各点到root的距离,记录在tmp中</span></span><br><span class="line">    tmp[++cnt]=dist[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v==fa||vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dist[v]=dist[x]+e[i].w;</span><br><span class="line">        <span class="built_in">getdist</span>(v,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> q[<span class="number">105</span>];<span class="comment">//q记录询问距离</span></span><br><span class="line"><span class="type">bool</span> jud[maxk],ans[<span class="number">105</span>];<span class="comment">//存放之前子树中的存在路径长度,ans判断k是否存在</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; QwQ;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//处理经过根节点x的路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])<span class="comment">//该点已经被去掉</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        dist[v]=e[i].w;<span class="comment">//设置root与儿子的距离</span></span><br><span class="line">        <span class="built_in">getdist</span>(v,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)<span class="comment">//遍历该子树上的距离</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)<span class="comment">//遍历询问</span></span><br><span class="line">                <span class="keyword">if</span>(q[k]&gt;=tmp[j])<span class="comment">//有拼出来的可能性</span></span><br><span class="line">                    ans[k]|=jud[q[k]-tmp[j]];<span class="comment">//可以用之前以x为顶的距离拼起来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)<span class="comment">//将这棵子树的距离存起来</span></span><br><span class="line">        &#123;<span class="comment">//供之后的以x为节点的子树拼路径使用</span></span><br><span class="line">            QwQ.<span class="built_in">push</span>(tmp[j]);</span><br><span class="line">            jud[tmp[j]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!QwQ.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        jud[QwQ.<span class="built_in">front</span>()]=<span class="number">0</span>;</span><br><span class="line">        QwQ.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x]=jud[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//去掉根节点x</span></span><br><span class="line">    <span class="built_in">solve</span>(x);<span class="comment">//处理所有经过x的路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        maxp[root=<span class="number">0</span>]=sum=siz[v];<span class="comment">//重心置为0,maxp[0]置为最大值(所以要重新DFS计算siz)</span></span><br><span class="line">        <span class="built_in">getrt</span>(v,<span class="number">0</span>);<span class="comment">//在以v为根的子树上找重心</span></span><br><span class="line">        <span class="built_in">getrt</span>(root,<span class="number">0</span>);<span class="comment">//处理出以v为根的siz数组</span></span><br><span class="line">        <span class="built_in">divide</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k,u,v;</span><br><span class="line">    ll w;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;<span class="comment">//点u到点v距离为w</span></span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        cin&gt;&gt;q[i];</span><br><span class="line">    maxp[<span class="number">0</span>]=sum=n;<span class="comment">//置为最大值</span></span><br><span class="line">    <span class="built_in">getrt</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">getrt</span>(root,<span class="number">0</span>);<span class="comment">//更新以重心为根的siz数组</span></span><br><span class="line">    <span class="built_in">divide</span>(root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        cout&lt;&lt;(ans[i]?<span class="string">&quot;AYE&quot;</span>:<span class="string">&quot;NAY&quot;</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="树上启发式合并（DSU-on-tree）"><a href="#树上启发式合并（DSU-on-tree）" class="headerlink" title="树上启发式合并（DSU on tree）"></a>树上启发式合并（DSU on tree）</h3><p>解决<strong>离线子树查询</strong>问题，即统计树上一个节点的子树中具有某种特征的节点数。</p>
<p>一般也可以使用DFS序莫队或DFS序主席树做。</p>
<p>时间复杂度$O(nlogn)$，空间复杂度$O(n)$。</p>
<h4 id="流程-4"><a href="#流程-4" class="headerlink" title="流程"></a>流程</h4><ol>
<li>先用dfs处理出重儿子</li>
<li>使用DFS处理各子树信息，设当前子树根节点为x<ul>
<li><strong>遍历</strong>x的轻儿子，计算轻儿子子树贡献，<strong>记录到ans数组</strong>，信息不做保留。</li>
<li>处理x的重儿子子树贡献，<strong>记录到ans数组</strong>，并保留。</li>
<li>暴力统计节点x及所有轻儿子子树贡献，与x的重儿子子树贡献汇总，一同<strong>回溯</strong>到上一级，以便处理出以x节点的父节点为根的子树的贡献。</li>
</ul>
</li>
</ol>
<h4 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> head[maxn],tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,nex;</span><br><span class="line">&#125; e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].v=v;</span><br><span class="line">    e[tot].nex=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> siz[maxn],son[maxn];<span class="comment">//记录当前节点的重儿子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span><span class="comment">//找重儿子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,x);</span><br><span class="line">        siz[x]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[son[x]])</span><br><span class="line">            son[x]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> color[maxn],cnt[maxn];<span class="comment">//存放各个节点颜色,cnt存放当前树中各颜色数量</span></span><br><span class="line">ll ans[maxn],sum;<span class="comment">//答案数组,当前子树答案</span></span><br><span class="line"><span class="type">int</span> flag,maxc;<span class="comment">//标记重儿子,更新最大color数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa,<span class="type">int</span> val)</span><span class="comment">//暴力更新x节点及其轻儿子子树贡献</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//val=1表示增加贡献,-1表示消去贡献</span></span><br><span class="line">    cnt[color[x]]+=val;</span><br><span class="line">    <span class="keyword">if</span>(cnt[color[x]]&gt;maxc)</span><br><span class="line">    &#123;</span><br><span class="line">        sum=color[x];<span class="comment">//更新数量最多的颜色之和</span></span><br><span class="line">        maxc=cnt[color[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt[color[x]]==maxc)</span><br><span class="line">        sum+=color[x];<span class="comment">//颜色之和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v==fa||v==flag)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">cal</span>(v,x,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa,<span class="type">bool</span> keep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=e[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v==fa||v==son[x])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x])<span class="comment">//处理所有轻儿子节点后,处理重儿子子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(son[x],x,<span class="number">1</span>);</span><br><span class="line">        flag=son[x];<span class="comment">//标记当前重儿子,防止统计x及轻儿子时访问x的重儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cal</span>(x,fa,<span class="number">1</span>);<span class="comment">//处理x节点自身颜色</span></span><br><span class="line">    ans[x]=sum;</span><br><span class="line">    flag=<span class="number">0</span>;<span class="comment">//置0,防止影响计算</span></span><br><span class="line">    <span class="keyword">if</span>(!keep)<span class="comment">//轻儿子不做保留,消去信息</span></span><br><span class="line">    &#123;<span class="comment">//重儿子保留,回溯到上一级时</span></span><br><span class="line"><span class="comment">//        cal(x,fa,-1);//这么写复杂度会低些</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        sum=maxc=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">//求每个子树上出现次数最多的数字之和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;color[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p><del>二分图如果不考虑复杂度的话，可以用网络流来做。</del></p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>最大匹配：二分图中边集的数目最大的匹配。</li>
<li>匹配：子图$M$上任意两条边都不依附于同一个顶点，则称$M$为原图的匹配。</li>
<li>点覆盖：图$G&#x3D;(V,E)$中的一个点覆盖为一个集合$S⊆V$使得<strong>每条边至少有一个端点</strong>在$S$中。</li>
<li>最小点覆盖：点个数最少的$S$集合。</li>
<li>最小边覆盖：用最少不相交简单路径覆盖DAG所有顶点。</li>
<li>最小点权覆盖：覆盖每个节点都需要一定代价，覆盖所有边总代价最小的点集。</li>
<li>最大独立集：在点集$V$中选出$M$个点，$M$中点与点两两无边，并使$M$最大。</li>
</ul>
<h4 id="常见二分图结论"><a href="#常见二分图结论" class="headerlink" title="常见二分图结论"></a>常见二分图结论</h4><ul>
<li><strong>最小点覆盖&#x3D;二分图最大匹配</strong></li>
<li>最小边覆盖&#x3D;顶点数-最小顶点覆盖（二分图最大匹配）</li>
<li>最大独立集&#x3D;顶点数-最大匹配数</li>
<li>所有回路长度均为偶数</li>
</ul>
<h4 id="适用任意图的结论"><a href="#适用任意图的结论" class="headerlink" title="适用任意图的结论"></a>适用任意图的结论</h4><ul>
<li><p>对于不存在孤立点的图，最大匹配+最小边覆盖&#x3D;顶点数</p>
</li>
<li><p>最大独立集+最小顶点覆盖&#x3D;顶点数</p>
</li>
</ul>
<h4 id="二分图判定（黑白染色法）"><a href="#二分图判定（黑白染色法）" class="headerlink" title="二分图判定（黑白染色法）"></a>二分图判定（黑白染色法）</h4><p>A、B集合分别染成不同颜色（由边链接的两节点颜色一定不同）</p>
<p>A集合中选取一个起始节点，将邻接的点染成与其不同的颜色，如果邻接的点有相同颜色的，则说明不是二分图</p>
<h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4><h5 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5><p>时间复杂度O(nm)，有重边时使用邻接矩阵？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">205</span>;<span class="comment">//在主函数内向关系图G中加边</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxn];<span class="comment">//注意使用前clear()</span></span><br><span class="line"><span class="type">int</span> linker[maxn];</span><br><span class="line"><span class="type">bool</span> used[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:G[x])</span><br><span class="line">        <span class="keyword">if</span>(!used[v])<span class="comment">//在右边找</span></span><br><span class="line">        &#123;</span><br><span class="line">            used[v]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!linker[v]||<span class="built_in">dfs</span>(linker[v]))</span><br><span class="line">            &#123;</span><br><span class="line">                linker[v]=x;<span class="comment">//记录右边v号匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//未找到增广路</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hungry</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(linker,<span class="number">0</span>,<span class="built_in">sizeof</span>(linker));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//遍历左面</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="built_in">sizeof</span>(used));</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(i))<span class="comment">//能找到增广路</span></span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h4><ul>
<li>二分图最佳完美匹配：带权二分图，求一种<strong>完备匹配</strong>方案，使得所有<strong>匹配边的权和最大</strong>。</li>
</ul>
<h5 id="BFS，复杂度稳的一批"><a href="#BFS，复杂度稳的一批" class="headerlink" title="BFS，复杂度稳的一批"></a>BFS，复杂度稳的一批</h5><p>复杂度$O(n^3)$，使用时清空w数组，并且按照关系为w赋值，调用KM(n)即可得到匹配边权值和。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> w[maxn][maxn];<span class="comment">//二分图间的权值</span></span><br><span class="line"><span class="type">int</span> lx[maxn],ly[maxn];</span><br><span class="line"><span class="type">int</span> linker[maxn];<span class="comment">//B图匹配到的A图节点</span></span><br><span class="line"><span class="type">int</span> slack[maxn];</span><br><span class="line"><span class="type">bool</span> visy[maxn];<span class="comment">//记录每一轮B图匹配过</span></span><br><span class="line"><span class="type">int</span> pre[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y=<span class="number">0</span>,yy=<span class="number">0</span>,delta;</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        slack[i]=INF;</span><br><span class="line">    linker[y]=k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=linker[y];</span><br><span class="line">        delta=INF;</span><br><span class="line">        visy[y]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visy[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(slack[i]&gt;lx[x]+ly[i]-w[x][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    slack[i]=lx[x]+ly[i]-w[x][i];</span><br><span class="line">                    pre[i]=y;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(slack[i]&lt;delta)</span><br><span class="line">                    delta=slack[i],yy=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( visy[i] )</span><br><span class="line">                lx[linker[i]]-=delta,ly[i]+=delta;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                slack[i]-=delta;</span><br><span class="line">        &#125;</span><br><span class="line">        y=yy;</span><br><span class="line">        <span class="keyword">if</span>(linker[y]==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">        linker[y]=linker[pre[y]],y=pre[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KM</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(lx,<span class="number">0</span>,<span class="built_in">sizeof</span>(lx));</span><br><span class="line">    <span class="built_in">memset</span>(ly,<span class="number">0</span>,<span class="built_in">sizeof</span>(ly));</span><br><span class="line">    <span class="built_in">memset</span>(linker,<span class="number">-1</span>,<span class="built_in">sizeof</span>(linker));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(visy,<span class="literal">false</span>,<span class="built_in">sizeof</span>(visy));</span><br><span class="line">        <span class="built_in">bfs</span>(i,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(linker[i]!=<span class="number">-1</span>)</span><br><span class="line">            ans+=w[linker[i]][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="左右数目不等的模板"><a href="#左右数目不等的模板" class="headerlink" title="左右数目不等的模板"></a>左右数目不等的模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> wx[maxn],wy[maxn],match[maxn];</span><br><span class="line"><span class="type">int</span> mp[maxn][maxn],slack[maxn],pre[maxn];</span><br><span class="line"><span class="type">bool</span> viy[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> py=<span class="number">0</span>,px,yy=<span class="number">0</span>,delta;</span><br><span class="line">    match[py]=k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)pre[i]=<span class="number">0</span>,slack[i]=inf;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        px=match[py],delta=inf,viy[py]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!viy[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(wx[px]+wy[i]-mp[px][i]&lt;slack[i])slack[i]=wx[px]+wy[i]-mp[px][i],pre[i]=py;</span><br><span class="line">                <span class="keyword">if</span>(slack[i]&lt;delta)delta=slack[i],yy=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(viy[i])wx[match[i]]-=delta,wy[i]+=delta;</span><br><span class="line">            <span class="keyword">else</span> slack[i]-=delta;</span><br><span class="line">        &#125;</span><br><span class="line">        py=yy;</span><br><span class="line">    &#125;<span class="keyword">while</span>(match[py]!=<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(py)match[py]=match[pre[py]],py=pre[py];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">km</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//n&gt;=m,mp[m][n]这样输入匹配权值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        wy[i]=<span class="number">0</span>,match[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        wx[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            wx[i]=<span class="built_in">max</span>(wx[i],mp[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="built_in">memset</span>(viy,<span class="number">0</span>,<span class="built_in">sizeof</span>(viy)),<span class="built_in">bfs</span>(i,n,m);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ans+=wx[match[i]]+wy[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="CSL的写法"><a href="#CSL的写法" class="headerlink" title="CSL的写法"></a>CSL的写法</h5>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">305</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;<span class="comment">//KM算法:带权的二分图中寻找*权值和最大*的完备匹配</span></span><br><span class="line"><span class="type">int</span> cost[maxn][maxn];<span class="comment">//A[i]连接B[j]的权值</span></span><br><span class="line"><span class="type">int</span> lx[maxn], ly[maxn];</span><br><span class="line"><span class="type">int</span> match[maxn], slack[maxn];<span class="comment">//B[i]匹配到的A,</span></span><br><span class="line"><span class="type">int</span> previous[maxn];</span><br><span class="line"><span class="type">bool</span> vy[maxn];<span class="comment">//匹配过</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">augment</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(vy + <span class="number">1</span>, vy + n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">fill</span>(slack + <span class="number">1</span>, slack + n + <span class="number">1</span>, INF);</span><br><span class="line">    <span class="type">int</span> py;</span><br><span class="line">    match[py = <span class="number">0</span>] = root;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        vy[py] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> x = match[py], yy;</span><br><span class="line">        <span class="type">int</span> delta = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt;= n; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vy[y])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (lx[x] + ly[y] - cost[x][y] &lt; slack[y])</span><br><span class="line">                    slack[y] = lx[x] + ly[y] - cost[x][y], previous[y] = py;</span><br><span class="line">                <span class="keyword">if</span> (slack[y] &lt; delta)</span><br><span class="line">                    delta = slack[y], yy = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt;= n; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vy[y])</span><br><span class="line">                lx[match[y]] -= delta, ly[y] += delta;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                slack[y] -= delta;</span><br><span class="line">        &#125;</span><br><span class="line">        py = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(match[py] != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pre = previous[py];</span><br><span class="line">        match[py] = match[pre], py = pre;</span><br><span class="line">    &#125; <span class="keyword">while</span> (py);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KM</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lx[i] = ly[i] = <span class="number">0</span>;</span><br><span class="line">        match[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            lx[i] = <span class="built_in">max</span>(lx[i], cost[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> answer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> root = <span class="number">1</span>; root &lt;= n; root++)</span><br><span class="line">        <span class="built_in">augment</span>(root,n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        answer += lx[i], answer += ly[i];</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><p>注意反向思考，添加新节点进行限流。</p>
<p>最小点覆盖&#x3D;最大匹配 (与最大流最小割定理等价)。<br>最大独立集&#x3D;点数-最大匹配 (独立集为点覆盖的补集)。<br>最小边覆盖&#x3D;最大独立集 (独立集中每个点需要一条边去覆盖)。</p>
<h4 id="最大独立集"><a href="#最大独立集" class="headerlink" title="最大独立集"></a>最大独立集</h4><p>方格取数问题</p>
<p>二分图最大独立集&#x3D;顶点数-最大匹配数&#x3D;点数-最小割</p>
<p>如果是点有点权，要求集合内两两无冲的情况下求集合最大价值。那么建立二分图，超级源点$s$和超级汇点$t$，因为图必须是二分图，分成黑点和白点两部分，黑点中与白点有关系，则连接一条容量为$inf$的边，黑点向$s$连一条容量为点价值的边，同样白点向$t$连一条容量为点价值的边。跑最大流求得最小割。</p>
<h4 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h4><p>定义有向图$G&#x3D;(V,E)$的一个闭合子图是该<strong>有向图</strong>的一个点集，其中这个点集中的所有点的<strong>出边</strong>连向的还是<strong>点集中的点</strong>。</p>
<h5 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h5><p>加入超级源点$S$和超级汇点$T$，构造网络$G&#x3D;(V,E)$：</p>
<ul>
<li>$S$与所有<strong>正权点</strong>连边，容量为正权点权值。</li>
<li>负权点向$T$连边，容量为负权点的绝对值。</li>
<li>0权点无影响可以任意当作正权点或负权点。</li>
<li>原图中的边保持不变，容量为$INF$。</li>
</ul>
<p>原图对应的最大权闭合图的权值和为<strong>所有正权点的权值和减去最小割</strong>。</p>
<h4 id="最大密度子图"><a href="#最大密度子图" class="headerlink" title="最大密度子图"></a>最大密度子图</h4><p>定义一个无向图$G&#x3D;(V,E)$的密度$D$为边数$|E|$和点数$|V|$的比值，即$D &#x3D; \dfrac{|E|}{|V|}$.</p>
<p>最大密度子图$G’$即为无向图$G$的一个子图且具有最大的$D$.</p>
<h5 id="解法1-二分，复杂度-logn-maxflow-n-m-n-m"><a href="#解法1-二分，复杂度-logn-maxflow-n-m-n-m" class="headerlink" title="解法1.二分，复杂度$logn.maxflow(n+m,n+m)$"></a>解法1.二分，复杂度$logn.maxflow(n+m,n+m)$</h5><p>二分答案$g$，下界为$\dfrac{1}{n}$，上界为$\dfrac{m}{1}$.</p>
<p>构造一个函数$h(g)&#x3D;max(|E’|-g|V’|)$，子图.</p>
<p>设最优密度为$D$，当$h(g)&#x3D;0$时$g$即为答案.<br>$$<br>\begin{cases}<br>h(g)&lt;0 &amp; g&gt;D\<br>h(g)&#x3D;0 &amp; g&#x3D;D\<br>h(g)&gt;0 &amp; g&lt;D<br>\end{cases}<br>$$<br><img src="https://images.cnblogs.com/cnblogs_com/kikokiko/1638452/o_200601055952%E6%9C%80%E5%A4%A7%E5%AF%86%E5%BA%A6%E5%AD%90%E5%9B%BE1.png" alt="img" style="zoom: 33%;"></p>
<p>对于每条边$e&lt;u,v&gt; \in E$，加入子图的前提是$u,v$都在子图中，所以这部分可用最大闭合子图解决：</p>
<ul>
<li>每条边$e$作为一个点，$e$向这条边的两个端点$u,v$连$INF$的边.</li>
<li>s向所有原图中的边连边，容量为$1$.</li>
<li>原图中的点向t连边，容量为$g$.</li>
</ul>
<img src="https://images.cnblogs.com/cnblogs_com/kikokiko/1638452/o_200601065356%E6%9C%80%E5%A4%A7%E5%AF%86%E5%BA%A6%E5%AD%90%E5%9B%BE2%20(2).png" alt="img" style="zoom: 33%;">

<p>搜索残余网络中源点可以到达的点即可得到子图中的点。</p>
<h5 id="POJ-3155-Hard-Life"><a href="#POJ-3155-Hard-Life" class="headerlink" title="POJ-3155 Hard Life"></a><a target="_blank" rel="noopener" href="http://poj.org/problem?id=3155">POJ-3155 <strong>Hard Life</strong></a></h5><p>抱歉这题我写疯了过不去，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29169749/article/details/54835145">贴了别人的代码</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">translation:</span></span><br><span class="line"><span class="comment">    公司里面有若干职员，每个职员都有一个或者若干个和自己不和的人，如果让两个不和的人在一起工作，则效率必然下降。</span></span><br><span class="line"><span class="comment">    定义一个hard因子。hard:=互相不和的职工对数 / 总人数。现在求从公司里面选出一些人出来，使得hard因子最大。</span></span><br><span class="line"><span class="comment">solution:</span></span><br><span class="line"><span class="comment">    网络流解决最大密度子图。</span></span><br><span class="line"><span class="comment">    paper题，参考论文“最小割模型在信息学竞赛中的应用”一文。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">116</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, rev;</span><br><span class="line">    <span class="type">double</span> cap;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> to_, <span class="type">int</span> rev_, <span class="type">double</span> cap_):<span class="built_in">to</span>(to_),<span class="built_in">rev</span>(rev_),<span class="built_in">cap</span>(cap_)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; G[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="type">int</span> level[maxn], n, m, s, t;</span><br><span class="line"><span class="type">int</span> iter[maxn], sum;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> first, second;</span><br><span class="line">&#125; p[<span class="number">1024</span>];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> d[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;add edge from %d to %d, cap = %lf\n&quot;, from, to, cap);</span></span><br><span class="line">    G[from].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, G[to].<span class="built_in">size</span>(), cap));</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from, G[from].<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(level, <span class="number">-1</span>, <span class="built_in">sizeof</span>(level));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    level[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> v = q.<span class="built_in">front</span>();  q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[v].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            Edge&amp; e = G[v][i];</span><br><span class="line">            <span class="keyword">if</span>(e.cap &gt; eps &amp;&amp; level[e.to] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                level[e.to] = level[v] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">min</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> t, <span class="type">double</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;@%d %d\n&quot;, v, t);</span></span><br><span class="line">    <span class="keyword">if</span>(v == t)  <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; i = iter[v]; i &lt; G[v].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        Edge&amp; e = G[v][i];</span><br><span class="line">        <span class="keyword">if</span>(e.cap &gt; <span class="number">0</span> &amp;&amp; level[e.to] &gt; level[v]) &#123;</span><br><span class="line">            <span class="type">double</span> dt = <span class="built_in">dfs</span>(e.to, t, <span class="built_in">min</span>(f, e.cap));</span><br><span class="line">            <span class="keyword">if</span>(dt &gt; eps) &#123;</span><br><span class="line">                e.cap -= dt;</span><br><span class="line">                G[e.to][e.rev].cap += dt;</span><br><span class="line">                <span class="keyword">return</span> dt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">max_flow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="built_in">bfs</span>(s);</span><br><span class="line">        <span class="keyword">if</span>(level[t] &lt; <span class="number">0</span>)    <span class="keyword">return</span> flow;</span><br><span class="line">        <span class="built_in">memset</span>(iter, <span class="number">0</span>, <span class="built_in">sizeof</span>(iter));</span><br><span class="line">        <span class="type">double</span> f;</span><br><span class="line">        <span class="keyword">while</span>((f = <span class="built_in">dfs</span>(s, t, INF)) &gt; eps)</span><br><span class="line">            flow += f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">add_edge</span>(s, i, m);</span><br><span class="line">        <span class="built_in">add_edge</span>(i, t, m + <span class="number">2</span> * k - d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = p[i].first, v = p[i].second;</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v, <span class="number">1.0</span>);</span><br><span class="line">        <span class="built_in">add_edge</span>(v, u, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> tmp = (n * m - <span class="built_in">max_flow</span>(s, t)) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp &gt; eps) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[v].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        Edge e = G[v][i];</span><br><span class="line">        <span class="keyword">if</span>(e.cap &gt; eps &amp;&amp; !vis[e.to])</span><br><span class="line">            <span class="built_in">dfs1</span>(e.to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;p[i].first, &amp;p[i].second);</span><br><span class="line">            d[p[i].first]++;</span><br><span class="line">            d[p[i].second]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n1\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s = <span class="number">0</span>;  t = n + <span class="number">1</span>;</span><br><span class="line">            <span class="type">double</span> lb = <span class="number">0.0</span>, ub = m * <span class="number">1.0</span>, mid;</span><br><span class="line">            <span class="type">double</span> precision = (<span class="type">double</span>)(<span class="number">1.0</span> / n / n);</span><br><span class="line">            <span class="keyword">while</span>(ub - lb &gt;= precision) &#123;</span><br><span class="line">                mid = (lb + ub) / <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//printf(&quot;# %lf %lf\n&quot;, lb, ub);</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(mid))  lb = mid;</span><br><span class="line">                <span class="keyword">else</span>            ub = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">check</span>(lb);</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">            <span class="built_in">dfs1</span>(<span class="number">0</span>);</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                <span class="keyword">if</span>(vis[i])  sum++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                <span class="keyword">if</span>(vis[i])  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及下面这个，我和他写的一样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">40018</span>,inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edg</span>&#123;</span><br><span class="line">    <span class="type">int</span> nxt,to;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="type">int</span> cnt,vis[maxn],head,tail,q[maxn],S,T,n,m,t,last[maxn],d[maxn];</span><br><span class="line"><span class="type">double</span> l,r,mid;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">double</span> z)</span></span>&#123;</span><br><span class="line">    ++t;e[t].nxt=last[x];last[x]=t;e[t].to=y;e[t].f=z;</span><br><span class="line">    ++t;e[t].nxt=last[y];last[y]=t;e[t].to=x;e[t].f=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dui</span>&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;qq[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head=tail=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">    q[++tail]=S;d[S]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head&lt;tail)&#123;</span><br><span class="line">        <span class="type">int</span> u=q[++head];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=last[u];i;i=e[i].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(e[i].f&amp;&amp;d[v]==<span class="number">-1</span>)&#123;</span><br><span class="line">                d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">                q[++tail]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[T]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">double</span> h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==T)&#123;<span class="keyword">return</span> h;&#125;</span><br><span class="line">    <span class="type">double</span> tmp=<span class="number">0</span>,cp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=last[x];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(e[i].f&amp;&amp;d[v]==d[x]+<span class="number">1</span>)&#123;</span><br><span class="line">            cp=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(h-tmp,e[i].f));</span><br><span class="line">            e[i].f-=cp;e[i^<span class="number">1</span>].f+=cp;tmp+=cp;</span><br><span class="line">            <span class="keyword">if</span>(tmp==h)&#123;<span class="keyword">return</span> tmp;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tmp)d[x]=<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pd</span><span class="params">(<span class="type">double</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="built_in">sizeof</span>(last));t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">add</span>(n+i,qq[i].from,inf);</span><br><span class="line">        <span class="built_in">add</span>(n+i,qq[i].to,inf);</span><br><span class="line">        <span class="built_in">add</span>(S,n+i,<span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">add</span>(i,T,mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> pp,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(pp=<span class="built_in">dfs</span>(S,inf))res+=pp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;res&lt;&lt;&#x27; &#x27;&lt;&lt;m&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">double</span>(m)-res)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n)cnt++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=last[x];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(e[i].f&amp;&amp;!vis[v])<span class="built_in">dfs1</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;qq[i].from,&amp;qq[i].to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!m)&#123;<span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);<span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    l=<span class="number">0</span>,r=m+<span class="number">1</span>;S=n+m+<span class="number">1</span>,T=n+m+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;=<span class="number">1.0</span>/n/n)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line">        mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(mid))l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pd</span>(l);</span><br><span class="line">    <span class="built_in">dfs1</span>(S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模板部分"><a href="#模板部分" class="headerlink" title="模板部分"></a>模板部分</h4><h5 id="dinic"><a href="#dinic" class="headerlink" title="dinic"></a>dinic</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Dinic</span></span><br><span class="line">&#123;<span class="comment">//复杂度O(n^2m)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> from, to, cap, flow;</span><br><span class="line">        <span class="built_in">Edge</span>(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> f):</span><br><span class="line">            <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> n, m, s, t; <span class="comment">//结点数,边数(包括反向弧),源点编号和汇点编号</span></span><br><span class="line">    vector&lt;Edge&gt; edges; <span class="comment">//边表。edge[e]和edge[e^1]互为反向弧</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; G[maxn]; <span class="comment">//邻接表，G[i][j]表示节点i的第j条边在e数组中的序号</span></span><br><span class="line">    <span class="type">bool</span> vis[maxn]; <span class="comment">//BFS使用</span></span><br><span class="line">    <span class="type">int</span> d[maxn]; <span class="comment">//从起点到i的距离</span></span><br><span class="line">    <span class="type">int</span> cur[maxn]; <span class="comment">//当前弧下标</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) G[i].<span class="built_in">clear</span>();</span><br><span class="line">        edges.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> cap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from, to, cap, <span class="number">0</span>));</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>));<span class="comment">//反向弧,初始容量为0</span></span><br><span class="line">        m = edges.<span class="built_in">size</span>();</span><br><span class="line">        G[from].<span class="built_in">push_back</span>(m - <span class="number">2</span>);</span><br><span class="line">        G[to].<span class="built_in">push_back</span>(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="comment">//        memset(d, 0, sizeof(d));</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        vis[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                &#123;<span class="comment">//只考虑残量网络中的弧</span></span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                    d[e.to] = d[x] + <span class="number">1</span>;<span class="comment">//构造分层图</span></span><br><span class="line">                    q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[t];<span class="comment">//有无增广路,s-&gt;t</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> a)</span><span class="comment">//x为当前点,a为当前边上流量</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//在层次图上向t延伸,多路增广</span></span><br><span class="line">        <span class="keyword">if</span>(x==t||a==<span class="number">0</span>)<span class="comment">//到达目标/流量为0断流</span></span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="type">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; i=cur[x];i&lt;G[x].<span class="built_in">size</span>();i++)<span class="comment">//从上一次x遍历跑到的点开始跑</span></span><br><span class="line">        &#123;<span class="comment">//从上次考虑的弧</span></span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span>(d[x]+<span class="number">1</span>==d[e.to]&amp;&amp;(f=<span class="built_in">DFS</span>(e.to,<span class="built_in">min</span>(a,e.cap-e.flow))) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;<span class="comment">//只从层数编号较小的点到下一层的点</span></span><br><span class="line">                e.flow += f;<span class="comment">//该路径上边流量都增加f</span></span><br><span class="line">                edges[G[x][i]^<span class="number">1</span>].flow -= f;<span class="comment">//方便反悔</span></span><br><span class="line">                flow += f;</span><br><span class="line">                a -= f;<span class="comment">//用去可增广量</span></span><br><span class="line">                <span class="keyword">if</span>(a==<span class="number">0</span>)<span class="comment">//a等于0及时退出</span></span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//当a!=0,说明当前节点还存在另一个增广路分支。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flow)<span class="comment">//增广后容量满了</span></span><br><span class="line">            d[x] = <span class="number">-1</span>;<span class="comment">//炸点优化,不必要的点下一次就不用遍历</span></span><br><span class="line">        <span class="keyword">return</span> flow;<span class="comment">//返回x节点最大流量,传递到上一级</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Maxflow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s, <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">BFS</span>())<span class="comment">//不停地用bfs构造分层网络，然后用dfs沿着阻塞流增广</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in">sizeof</span>(cur));<span class="comment">//建完分层图后cur也要初始化</span></span><br><span class="line">            flow += <span class="built_in">DFS</span>(s,inf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; di;</span><br></pre></td></tr></table></figure>

<h5 id="dijkstra费用流"><a href="#dijkstra费用流" class="headerlink" title="dijkstra费用流"></a>dijkstra费用流</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MCMF</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = ll;<span class="comment">//有时费用是double</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        ll v, cap;</span><br><span class="line">        type cost;</span><br><span class="line">        ll rev;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">const</span> type INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">    ll flow, s, t, n;<span class="comment">//跑完的最大流</span></span><br><span class="line">    type cost;<span class="comment">//跑完最大流下的最小费用</span></span><br><span class="line">    type dist[maxn], H[maxn];<span class="comment">//H为节点势函数</span></span><br><span class="line">    ll pv[maxn], pe[maxn];<span class="comment">//前驱结点和对应边</span></span><br><span class="line">    std::vector&lt;Edge&gt; G[maxn];<span class="comment">//因为要记录前驱,不能用前向星</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> cap, type cost)</span></span>&#123;<span class="comment">//dijk费用流中两节点间流向单向</span></span><br><span class="line">        G[u].<span class="built_in">push_back</span>(&#123;v,cap,cost,G[v].<span class="built_in">size</span>()&#125;);</span><br><span class="line">        G[v].<span class="built_in">push_back</span>(&#123;u,<span class="number">0</span>,-cost,G[u].<span class="built_in">size</span>()<span class="number">-1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dijkstra</span><span class="params">()</span><span class="comment">//这里是单路增广</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//复杂度相对SPFA稳定</span></span><br><span class="line">        std::priority_queue&lt;pair&lt;type,ll&gt;, std::vector&lt;pair&lt;type,ll&gt;&gt;, std::greater&lt;pair&lt;type,ll&gt;&gt; &gt; q;</span><br><span class="line">        std::<span class="built_in">fill</span>(dist, dist + n + <span class="number">1</span>, INF);</span><br><span class="line">        dist[s] = <span class="number">0</span>; q.<span class="built_in">push</span>(&#123; <span class="number">0</span>, s &#125;);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;<span class="comment">//到x距离即为到x的单位花费之和</span></span><br><span class="line">            pair&lt;type,ll&gt; x = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            ll&amp; u = x.second;</span><br><span class="line">            <span class="keyword">if</span> (dist[u] &lt; x.first) <span class="keyword">continue</span>;<span class="comment">//不能优化距离</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                Edge&amp; e = G[u][i];<span class="comment">//当前边</span></span><br><span class="line">                ll&amp; v = e.v;</span><br><span class="line">                <span class="function">pair&lt;type,ll&gt; <span class="title">y</span><span class="params">(dist[u] + e.cost + H[u] - H[v], v)</span></span>;</span><br><span class="line">                <span class="keyword">if</span> (e.cap &gt; <span class="number">0</span> &amp;&amp; dist[v] &gt; y.first)</span><br><span class="line">                &#123;</span><br><span class="line">                    dist[v] = y.first;</span><br><span class="line">                    pv[v] = u,pe[v] = i;<span class="comment">//前驱点与前驱边</span></span><br><span class="line">                    q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dist[t] == INF)<span class="comment">//无法增广</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)<span class="comment">//更新每轮的势函数</span></span><br><span class="line">            H[i] += dist[i];</span><br><span class="line">        ll f = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = t; v != s; v = pv[v])<span class="comment">//沿增广路回到起点</span></span><br><span class="line">            f = std::<span class="built_in">min</span>(f, G[pv[v]][pe[v]].cap);</span><br><span class="line">        flow += f;<span class="comment">//每次增广一条路径,这条路径增广量就是新增的流量</span></span><br><span class="line">        cost += f * H[t];<span class="comment">//h[t]-h[s]即为s到t的路径长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = t; v != s; v = pv[v])</span><br><span class="line">        &#123;<span class="comment">//更新增广路容量信息</span></span><br><span class="line">            Edge&amp; e = G[pv[v]][pe[v]];</span><br><span class="line">            e.cap -= f;</span><br><span class="line">            G[v][e.rev].cap += f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">solve</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s, <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        flow = cost = <span class="number">0</span>;</span><br><span class="line">        std::<span class="built_in">fill</span>(H, H + n + <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//初始网络为0非负,势函数也为0</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">dijkstra</span>());<span class="comment">//每次选择最小费用增广路径一定是当前残留图的最小增广路径</span></span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mm;</span><br></pre></td></tr></table></figure>
<h5 id="BF费用流"><a href="#BF费用流" class="headerlink" title="BF费用流"></a>BF费用流</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MCMF</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> from, to, cap, flow, cost;</span><br><span class="line">        <span class="built_in">Edge</span>(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> f, <span class="type">int</span> w)</span><br><span class="line">            : <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    vector&lt;Edge&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="type">int</span> inq[maxn]; <span class="comment">//是否在队列中</span></span><br><span class="line">    <span class="type">int</span> d[maxn]; <span class="comment">//bellmanford</span></span><br><span class="line">    <span class="type">int</span> p[maxn]; <span class="comment">//上一条弧</span></span><br><span class="line">    <span class="type">int</span> a[maxn]; <span class="comment">//可改进量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            G[i].<span class="built_in">clear</span>();</span><br><span class="line">        edges.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> cap, <span class="type">int</span> cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">//        edges.emplace_back(Edge(from, to, cap, 0, cost));</span></span><br><span class="line"><span class="comment">//        edges.emplace_back(Edge(to, from, 0, 0, -cost));</span></span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from, to, cap, <span class="number">0</span>, cost));</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>, -cost));</span><br><span class="line">        m = edges.<span class="built_in">size</span>();</span><br><span class="line">        G[from].<span class="built_in">push_back</span>(m - <span class="number">2</span>);</span><br><span class="line">        G[to].<span class="built_in">push_back</span>(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span>&amp; flow, ll&amp; cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            d[i] = inf;</span><br><span class="line">        <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="built_in">sizeof</span>(inq));</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        inq[s] = <span class="number">1</span>;</span><br><span class="line">        p[s] = <span class="number">0</span>;</span><br><span class="line">        a[s] = inf;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            inq[u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Edge&amp; e = edges[G[u][i]];</span><br><span class="line">                <span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost)</span><br><span class="line">                &#123;</span><br><span class="line">                    d[e.to] = d[u] + e.cost;</span><br><span class="line">                    p[e.to] = G[u][i];</span><br><span class="line">                    a[e.to] = <span class="built_in">min</span>(a[u], e.cap - e.flow);</span><br><span class="line">                    <span class="keyword">if</span> (!inq[e.to])</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                        inq[e.to] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;&quot;DE<span class="doctag">BUG:</span>BellmanFord\n&quot;;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;&quot;flow&quot;&lt;&lt;flow&lt;&lt;&quot;,cost=&quot;&lt;&lt;cost&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (d[t] == inf)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 当没有可增广的路时退出</span></span><br><span class="line">        flow += a[t];</span><br><span class="line">        cost += (ll)d[t] * (ll)a[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = t; u != s; u = edges[p[u]].from)</span><br><span class="line">        &#123;</span><br><span class="line">            edges[p[u]].flow += a[t];</span><br><span class="line">            edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MincostMaxflow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, ll&amp; cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">BellmanFord</span>(s, t, flow, cost));</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mm;</span><br></pre></td></tr></table></figure>



<h4 id="对偶图最小割"><a href="#对偶图最小割" class="headerlink" title="对偶图最小割"></a>对偶图最小割</h4><h4 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h4><h5 id="太空飞行计划问题（最小割-收益最大问题）"><a href="#太空飞行计划问题（最小割-收益最大问题）" class="headerlink" title="太空飞行计划问题（最小割,收益最大问题）"></a>太空飞行计划问题（最小割,收益最大问题）</h5><p> <strong>最优收益 &#x3D; 所有实验的报酬总和 - 该图的最大流</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m,n;<span class="comment">//实验数,仪器数</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line"><span class="type">int</span> s=<span class="number">0</span>,t=m+n+<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">di.<span class="built_in">init</span>(t);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> profit,equ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;profit);</span><br><span class="line">    sum+=profit;<span class="comment">//sum为所有收益之和</span></span><br><span class="line">    di.<span class="built_in">AddEdge</span>(s,i,profit);<span class="comment">//源点到实验</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%c&quot;</span>,&amp;equ,&amp;ch);</span><br><span class="line">        di.<span class="built_in">AddEdge</span>(i,m+equ,inf);<span class="comment">//实验到器材</span></span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;\r&#x27;</span>||ch==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cost;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cost);</span><br><span class="line">    di.<span class="built_in">AddEdge</span>(m+i,t,cost);<span class="comment">//器材到汇点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=di.<span class="built_in">Maxflow</span>(s,t);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(di.d[i])<span class="comment">//选择去做的实验编号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(di.d[m+i])<span class="comment">//需要购买的器材编号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>,sum-ans);</span><br></pre></td></tr></table></figure>
<p>建图后跑最大流求出最小割，满流的实验边割掉，满流的设备边也在割集里(但是这是需要购买的)，该最小割即为最小亏损。<br>所以最后一次BFS，所有未被割掉的实验为非饱和弧，可以求出深度。<br>所以未被割掉的实验(及选择去做的实验)所连接的设备同样可以求出深度。</p>
<h5 id="最小路径覆盖问题-最大流-最小不相交路径覆盖模型-要求路径数最少-路径输出"><a href="#最小路径覆盖问题-最大流-最小不相交路径覆盖模型-要求路径数最少-路径输出" class="headerlink" title="最小路径覆盖问题(最大流,最小不相交路径覆盖模型,要求路径数最少,路径输出)"></a>最小路径覆盖问题(最大流,最小不相交路径覆盖模型,要求路径数最少,路径输出)</h5><p>二分图定理之一：最小路径覆盖数&#x3D;顶点数-最大匹配。</p>
<p>覆盖所有的边：每条边下界设为1, 然后求最小流。 覆盖所有的点：建立二分图，对于$u\rightarrow v$的边，看做二分图中的$&lt;u,v&gt;$，然后答案为点数-最大匹配。</p>
<p>不要使用炸点优化！！！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma G++ optimize(&quot;O2&quot;)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">13005</span>;<span class="comment">//上大的模板</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> nex[maxn];</span><br><span class="line"><span class="type">bool</span> vist[maxn];</span><br><span class="line"><span class="type">int</span> all;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dinic</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> from, to, cap, flow;</span><br><span class="line">        <span class="built_in">Edge</span>(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> f):</span><br><span class="line">            <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> n, m, s, t; <span class="comment">//结点数,边数(包括反向弧),源点编号和汇点编号</span></span><br><span class="line">    vector&lt;Edge&gt; edges; <span class="comment">//边表。edge[e]和edge[e^1]互为反向弧</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; G[maxn]; <span class="comment">//邻接表，G[i][j]表示节点i的第j条边在e数组中的序号</span></span><br><span class="line">    <span class="type">bool</span> vis[maxn]; <span class="comment">//BFS使用</span></span><br><span class="line">    <span class="type">int</span> d[maxn]; <span class="comment">//从起点到i的距离</span></span><br><span class="line">    <span class="type">int</span> cur[maxn]; <span class="comment">//当前弧下标</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            G[i].<span class="built_in">clear</span>();</span><br><span class="line">        edges.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> cap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        edges.<span class="built_in">emplace_back</span>(<span class="built_in">Edge</span>(from, to, cap, <span class="number">0</span>));<span class="comment">//魔改蔡队模板</span></span><br><span class="line">        edges.<span class="built_in">emplace_back</span>(<span class="built_in">Edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">//反向弧</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m = edges.<span class="built_in">size</span>();</span><br><span class="line">        G[from].<span class="built_in">push_back</span>(m - <span class="number">2</span>);</span><br><span class="line">        G[to].<span class="built_in">push_back</span>(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        vis[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                    d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> a)</span><span class="comment">//x为当前点,a为当前边上流量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t || a == <span class="number">0</span>)<span class="comment">//到达目标/流量为0</span></span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="type">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123; <span class="comment">//从上次考虑的弧</span></span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x!=s)<span class="comment">//为了输出路径，添加此语句</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nex[x]=e.to;<span class="comment">//记录下一个节点,便于输出</span></span><br><span class="line">                    vist[e.to-all]=<span class="number">1</span>;<span class="comment">//打标记,找起点</span></span><br><span class="line">                &#125;</span><br><span class="line">                e.flow += f;</span><br><span class="line">                edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">                flow += f;</span><br><span class="line">                a -= f;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//这题不能乱用炸点优化！！！</span></span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Maxflow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s, <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">BFS</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in">sizeof</span>(cur));</span><br><span class="line">            flow += <span class="built_in">DFS</span>(s,inf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; di;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//给定DAG图G</span></span><br><span class="line">    <span class="type">int</span> n,m;<span class="comment">//n为DAG顶点数，m为边数</span></span><br><span class="line">    <span class="built_in">memset</span>(vist,<span class="number">0</span>,<span class="built_in">sizeof</span>(vist));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    all=n;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,t=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">    di.<span class="built_in">init</span>(t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//拆点，分别连接s和t</span></span><br><span class="line">    &#123;</span><br><span class="line">        di.<span class="built_in">AddEdge</span>(s,i,<span class="number">1</span>);</span><br><span class="line">        di.<span class="built_in">AddEdge</span>(n+i,t,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        di.<span class="built_in">AddEdge</span>(u,n+v,<span class="number">1</span>);<span class="comment">//容量为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=di.<span class="built_in">Maxflow</span>(s,t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vist[i])<span class="comment">//没标记的就是起点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> now=i;</span><br><span class="line">            cout&lt;&lt;now&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(nex[now]&amp;&amp;nex[now]!=t)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;nex[now]-n&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                now=nex[now]-n;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-ans&lt;&lt;endl;<span class="comment">//最少路径数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="P2774-方格取数问题-最大流，最小割"><a href="#P2774-方格取数问题-最大流，最小割" class="headerlink" title="P2774 方格取数问题(最大流，最小割)"></a>P2774 方格取数问题(最大流，最小割)</h5><p> m*n 个方格棋盘中，每个方格中有一个正整数。从方格中取数，使任意 2 个数所在方格没有公共边，且取出的数的总和最大。</p>
<p>思路：黑白染色，按奇偶性建立二分图，奇连s，偶连t。枚举每个奇数性质的方格，连接相邻的偶数性质的方格。跑dinic求出最小割，总值减去最小割即为答案。</p>
<p>带权最大独立集&#x3D;所有点的点权-最小割。因为是最小割的剩余图，所以剩下的点之间不会有联系，即为符合要求的答案。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);<span class="comment">//棋盘的行数和列数</span></span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,t=m*n+<span class="number">1</span>,sum=<span class="number">0</span>;<span class="comment">//sum为总价值</span></span><br><span class="line">    di.<span class="built_in">init</span>(t+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> val,no;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);<span class="comment">//i行j列的数值</span></span><br><span class="line">            sum+=val;</span><br><span class="line">            no=n*(i<span class="number">-1</span>)+j;<span class="comment">//重点：一行n个</span></span><br><span class="line">            <span class="keyword">if</span>((i+j)%<span class="number">2</span>)&#123;<span class="comment">//相邻的i+j奇偶性必定相斥</span></span><br><span class="line">                di.<span class="built_in">AddEdge</span>(s,no,val);<span class="comment">//根据奇偶性连接</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                di.<span class="built_in">AddEdge</span>(no,t,val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//s与t的边插入结束</span></span><br><span class="line">    <span class="type">int</span> nx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//只枚举两个方向是不够的,因为是有向图</span></span><br><span class="line">    <span class="type">int</span> ny[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//m行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//n列</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> no=n*(i<span class="number">-1</span>)+j;</span><br><span class="line">            <span class="keyword">if</span>((i+j)%<span class="number">2</span>)&#123;<span class="comment">//二分图左边的节点,开始连接右面的节点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)<span class="comment">//枚举方向,相邻的四个方格</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> x=i+nx[k],y=j+ny[k];<span class="comment">//x与m轴同方向</span></span><br><span class="line">                    <span class="keyword">if</span>(x&lt;=<span class="number">0</span>||x&gt;m||y&lt;=<span class="number">0</span>||y&gt;n)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="type">int</span> no2=n*(x<span class="number">-1</span>)+y;<span class="comment">//相邻的方格编号</span></span><br><span class="line">                    di.<span class="built_in">AddEdge</span>(no,no2,inf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum-di.<span class="built_in">Maxflow</span>(s,t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h4><h5 id="P4012-深海机器人问题（物品在网格上）"><a href="#P4012-深海机器人问题（物品在网格上）" class="headerlink" title="P4012 深海机器人问题（物品在网格上）"></a>P4012 深海机器人问题（物品在网格上）</h5><p>物品在网格的边上，每条网格的边有权值，交叉点作为节点，在图上添加点和点之间的边，设容量为1，花费为-cost。</p>
<p>注意设置容量inf，费用为0的经过边，跑最小费用最大流，答案取负。</p>
<h5 id="P3356-火星探险问题（物品在交叉点上）"><a href="#P3356-火星探险问题（物品在交叉点上）" class="headerlink" title="P3356 火星探险问题（物品在交叉点上）"></a>P3356 火星探险问题（物品在交叉点上）</h5><p>物品在节点上，而且有障碍。</p>
<p>思路：拆点，若不为障碍，拆点间添加容量为inf，价值为0的边；若该点有所需物品，两点间额外添加一条容量为1价值为-val的边；</p>
<p>跑最小费用最大流即可，使用DFS输出路径。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        mm.<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,i);<span class="comment">//起点(1,1),出点1,第i号机器人</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MCMF::dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> u,<span class="type">int</span> no)</span><span class="comment">//第no号机器人到达了u节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> kx,ky,dir;<span class="comment">//0向下,1向右</span></span><br><span class="line">    <span class="type">int</span> res=p*q+u;<span class="comment">//u节点的拆点编号</span></span><br><span class="line">    <span class="keyword">if</span>(flag)<span class="comment">//no号到达了终点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G[res].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(edges[G[res][i]].flow&gt;<span class="number">0</span>&amp;&amp;(edges[G[res][i]].to==u+<span class="number">1</span>||edges[G[res][i]].to==u+p))<span class="comment">//残余流量大于0</span></span><br><span class="line">        &#123;<span class="comment">//q行,p列,x与q同方向,表示第几行</span></span><br><span class="line">            edges[G[res][i]].flow--;</span><br><span class="line">            <span class="keyword">if</span>(edges[G[res][i]].to==u+<span class="number">1</span>)<span class="comment">//向右</span></span><br><span class="line">                dir=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dir=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,no,dir);</span><br><span class="line">            <span class="keyword">if</span>(dir==<span class="number">1</span>)</span><br><span class="line">                <span class="built_in">dfs</span>(x,y+<span class="number">1</span>,u+<span class="number">1</span>,no);</span><br><span class="line"><span class="comment">//                printf(&quot;(%d,%d)-&gt;(%d,%d)\n&quot;,x,y,x,y+1);</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">dfs</span>(x+<span class="number">1</span>,y,u+p,no);</span><br><span class="line"><span class="comment">//                printf(&quot;(%d,%d)-&gt;(%d,%d)\n&quot;,x,y,x+1,y);</span></span><br><span class="line">            <span class="keyword">if</span>(edges[G[res][i]].to==p*q)</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="P2604-扩容费用问题"><a href="#P2604-扩容费用问题" class="headerlink" title="P2604 扩容费用问题 "></a><a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P2604">P2604 扩容费用问题 </a></h5><p>问题：给出DAG每条边的容量和扩容费用，1.求出1到n的最大流。2.求出1到n的最大流增加K所需的最小扩容费用。</p>
<p>先跑一个零费用最大流。利用残余网络进行费用流扩容，将原来的0费用网络添加新的费用边，并进行<strong>限流</strong>，cost即为扩容费用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">mm.<span class="built_in">init</span>(n+<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].c&gt;&gt;e[i].w;</span><br><span class="line">    mm.<span class="built_in">AddEdge</span>(e[i].u,e[i].v,e[i].c,<span class="number">0</span>);<span class="comment">//费用为0，跑最大流</span></span><br><span class="line">&#125;</span><br><span class="line">ll cost;</span><br><span class="line">cout&lt;&lt;mm.<span class="built_in">MincostMaxflow</span>(<span class="number">1</span>,n,cost)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//给原来每条边上添加新边,</span></span><br><span class="line">    mm.<span class="built_in">AddEdge</span>(e[i].u,e[i].v,inf,e[i].w);</span><br><span class="line"><span class="type">int</span> s=<span class="number">0</span>;<span class="comment">//超级源点s</span></span><br><span class="line">mm.<span class="built_in">AddEdge</span>(s,<span class="number">1</span>,k,<span class="number">0</span>);<span class="comment">//s到1进行限流</span></span><br><span class="line">mm.<span class="built_in">MincostMaxflow</span>(s,n,cost);<span class="comment">//费用流</span></span><br><span class="line">cout&lt;&lt;cost&lt;&lt;endl;<span class="comment">//扩容费用</span></span><br></pre></td></tr></table></figure>






    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" rel="tag"># 算法模板</a>
              <a href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag"># 图论</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/06/24/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E7%9B%B8%E5%85%B3/%E7%8E%B0%E5%9C%A8%E7%BB%B4%E6%8A%A4%E7%9A%84%E6%A8%A1%E6%9D%BF/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="prev" title="动态规划代码模板">
                  <i class="fa fa-angle-left"></i> 动态规划代码模板
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/07/23/%E9%9D%A2%E7%BB%8F/%5B%E5%85%AB%E8%82%A1%E9%80%9F%E6%88%90%5D1.%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E4%B8%8EC++%E5%9F%BA%E7%A1%80/" rel="next" title="[八股速成]1.基本信息与C++基础">
                  [八股速成]1.基本信息与C++基础 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  
  <div class="comments giscus-container">
  </div>
  
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Overstars</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"Overstars/Hexo-Site-Comments-Section","repo_id":"R_kgDOKgH-yg","category":"Announcements","category_id":"DIC_kwDOKgH-ys4CaHxz","mapping":"title","reactions_enabled":1,"emit_metadata":0,"theme":"light_high_contrast","lang":"zh-CN","crossorigin":"anonymous","input_position":"top","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
